#ifndef _AUDIO_CORE_H_
#define _AUDIO_CORE_H_

// ----------------------------------------------------------------------------------
// core/system.c
// ----------------------------------------------------------------------------------
void create_audio_system(void);
//void nuAuPreNMIFuncSet(NUAuPreNMIFunc func);
void nuAuMgr(void* arg);
s32 nuAuDmaCallBack(s32 addr, s32 len, void *state, u8 useDma);
//ALDMAproc nuAuDmaNew(NUDMAState** state);
//void nuAuCleanDMABuffers(void);
//void nuAuPreNMIProc(NUScMsg mesg_type, u32 frameCounter);
//void alLink(ALLink* element, ALLink* after);
//void alUnlink(ALLink* element);

// ----------------------------------------------------------------------------------
//core/engine.c
// ----------------------------------------------------------------------------------
void au_release_voice(u8 index);
void au_engine_init(s32 outputRate);
static void au_reset_instrument(Instrument* instrument);
static void au_reset_drum_entry(BGMDrumInfo* arg0);
static void au_reset_instrument_entry(BGMInstrumentInfo* arg0);

/// this is called once per video frame update (50 or 60 times per second)
void au_update_clients_for_video_frame(void);

/// this is called per audio frame generated by alAudioFrame (every 184 audio samples)
/// there will be multiuple of these per video frame
void au_update_clients_for_audio_frame(void);

void au_syn_begin_audio_frame(AuGlobals* globals);
void au_reset_nonfree_voice(AuVoice* arg0, u8 arg1);
void au_reset_voice(AuVoice* voice, u8 voiceIdx);

/**
 * @brief Converts a linear pitch value (in cents) into a frequency ratio suitable for adjusting playback speed.
 *
 * This function computes the playback rate corresponding to a pitch shift (up or down) in cents.
 * Positive values increase pitch (higher frequency), and negative values decrease it.
 * Recall 100 cents = 1 semitone, and therefore 1200 cents = 1 octave.
 *
 * @param tuning The pitch offset in cents, from +4095 (~ 40.95 semitones up) to -16383 (~ 163.83 semitones down)
 *
 * @return Floating point output rate multiplier. Multiply this with the base sample rate to apply the pitch.
 */
f32 au_compute_pitch_ratio(s32 tuning);

void au_fade_init(Fade* fade, s32 time, s32 startValue, s32 endValue);
void au_fade_clear(Fade* fade);
void au_fade_update(Fade* fade);
void au_fade_set_volume(u8 arg0, u16 arg1, s32 arg2);
void au_fade_flush(Fade* fade);
void au_fade_set_envelope(Fade* fade, s16 value);
void au_fade_calc_envelope(Fade* fade, u32 arg1, s32 target);
void au_fade_update_envelope(Fade* fade);
Instrument* au_get_instrument(AuGlobals* globals, BankSetIndex bank, s32 patch, EnvelopeData* arg3);
void au_get_bgm_player_and_file(u32 playerIndex, BGMHeader** outCurrentTrackData, BGMPlayer** outPlayer);
void au_get_bgm_player(u32 playerIndex, BGMPlayer** outPlayer);
AuResult au_load_song_files(u32 arg0, BGMHeader* arg1, BGMPlayer* arg2);
AuResult au_reload_song_files(s32 songID, BGMHeader* arg1);
BGMPlayer* au_get_snapshot_by_index(s32 index);
AuResult au_ambient_load(u32 arg0);
BGMPlayer* au_get_client_by_priority(u8 arg0);
void au_load_INIT(AuGlobals* arg0, s32 romAddr, ALHeap* heap);
AuResult au_fetch_SBN_file(u32 fileIdx, AuFileFormat format, SBNFileEntry* arg2);
void au_load_PER(AuGlobals* globals, s32 romAddr);
void au_load_PRG(AuGlobals* arg0, s32 romAddr);
InstrumentBank* au_get_BK_instruments(BankSet bankSet, u32 bankIndex);
BKFileBuffer* au_load_BK_to_bank(s32 bkFileOffset, BKFileBuffer* bkFile, s32 bankIndex, BankSet bankSet);
void au_swizzle_BK_instruments(s32 bkFileOffset, BKFileBuffer* bkFile, InstrumentBank instruments, u32 instrumentCount, u8 arg4);
BKFileBuffer* au_load_static_BK_to_bank(s32* bkFileOffset, void* vaddr, s32 bankIndex, BankSet bankSet);
s32 au_load_aux_bank(s32 bkFileOffset, s32 bankIndex);
void au_clear_instrument_group(s32 bankIndex, BankSet bankSet);
void au_set_bus_volume_level(s32 arg0, u32 idx);
s32 au_set_reverb_type(s32 arg0, s32 arg1);
void au_sync_channel_delay_enabled(u32 arg0);
void au_read_rom(s32 romAddr, void* buffer, u32 size);
void au_memset(void* dst, s32 size, u8 value);
void au_copy_bytes(s8* src, s8* dest, s32 size);
void au_copy_words(void* src, void* dst, s32 size);

// ----------------------------------------------------------------------------------
// core/syn_driver.c
// ----------------------------------------------------------------------------------
void au_driver_init(AuSynDriver* driver, ALConfig* config);
void au_driver_release(void);
//Acmd* alAudioFrame(Acmd* cmdList, s32* cmdLen, s16* outBuf, s32 outLen);
void au_use_global_volume(void);
void au_set_global_volume(s16 arg0);
s16 au_get_global_volume(void);
void au_set_stereo_enabled(b8 enabled);
void au_bus_set_volume(u8 busID, u16 value);
u16 au_bus_get_volume(u8 busID);
void au_bus_set_effect(u8 busID, u8 effectID);
void au_bus_set_fx_params(u8 busID, s16 arg1, s16 arg2, s32 arg3);
void au_pvoice_set_bus(u8 voiceIdx, s8 busID);
void au_syn_stop_voice(u8 voiceIdx);
void au_syn_start_voice(u8 index);
void au_syn_start_voice_params(u8 index, u8 reverbType, Instrument* table, f32 pitch, s16 vol, u8 pan, u8 fxMix, s32 delta);
void au_syn_set_wavetable(u8 voiceIdx, Instrument* table);
void au_syn_set_pitch(u8 voiceIdx, f32 pitchRatio);
void au_syn_set_mixer_params(u8 voiceIdx, s16 volume, s32 arg2, u8 arg3, u8 arg4);
void au_syn_set_pan_fxmix(u8 voiceIdx, u8 arg1, u8 arg2);
void au_syn_set_volume_delta(u8 voiceIdx, s16 arg1, s32 arg2);
void au_syn_set_pan(u8 voiceIdx, u8 pan);
void au_syn_set_fxmix(u8 voiceIdx, u8 dryAmt);
s32 au_syn_get_playing(u8 voiceIdx);
s32 au_syn_get_bus(u8 voiceIdx);
f32 au_syn_get_pitch(u8 voiceIdx);
u8 au_syn_get_pan(u8 voiceIdx);
s16 au_syn_get_dryamt(u8 voiceIdx);
s16 au_syn_get_wetamt(u8 voiceIdx);
s32 au_syn_get_volume_left(u8 voiceIdx);
s32 au_syn_get_volume_right(u8 voiceIdx);
void au_set_delay_time(s32 arg0);
void au_delay_left_channel(u8 arg0);
void au_delay_right_channel(u8 arg0);
void au_disable_channel_delay(void);
void au_init_delay_channel(s16 arg0);
//void alHeapInit(ALHeap* hp, u8* base, s32 len);
//void alCopy(void* src, void* dst, s32 size);
#undef alHeapAlloc
void* alHeapAlloc(ALHeap* heap, s32 count, s32 size);

// ----------------------------------------------------------------------------------
// core/voice.c
// ----------------------------------------------------------------------------------

/**
 * (UNUSED)
 * Immediately flush all voices which have finished playing.
 * These are normally released automatically during the start of each audio frame.
 */
void au_flush_finished_voices(AuGlobals* globals);

/**
 * Initializes all voices in the audio system.
 * Sets default values and clears previous envelope state.
 */
void au_init_voices(AuGlobals* globals);

/**
 * Main envelope system update, called once per frame.
 * Progresses envelope state for all active voices.
 */
void au_update_voices(AuGlobals* globals);

/**
 * Applies volume update after a client-side volume change.
 * This is deferred to avoid modifying envelope state mid-step.
 */
void au_voice_after_volume_change(AuVoice* voice);

/**
 * @brief Converts envelope step duration from microseconds to num samples delta.
 *
 * Uses AU_FRAME_USEC as the base time slice, returning the number of audio samples
 * corresponding to the provided duration.
 *
 * @param msecs Time duration in microseconds.
 * @return Number of samples that should pass in this interval.
 */
s32 au_voice_get_delta(s32 usecs);

/**
 * @brief Starts a new voice with the given envelope data.
 *
 * Initializes envelope state and prepares the press phase for playback.
 *
 * @param voice Pointer to the voice being started.
 * @param envData Envelope command lists (press and release) to use.
 */
void au_voice_start(AuVoice* voice, EnvelopeData* envData);

/**
 * Parses and executes envelope commands until a time interval is found.
 * Commands include setting multipliers, loop control, etc.
 */
u8 au_voice_step(AuVoice* voice);

/**
 * (UNUSED)
 * Force recalculation of voice envelope volume during next update.
 */
void au_voice_set_vol_changed(AuVoice* voice);

// ----------------------------------------------------------------------------------
// core/pull_voice.c
// ----------------------------------------------------------------------------------
Acmd* au_pull_voice(AuPVoice* pvoice, Acmd* cmdBufPos);

// ----------------------------------------------------------------------------------
// core/reverb.c
// ----------------------------------------------------------------------------------
void au_fx_create(AuFX* fx, u8 mode, ALHeap* heap);
void au_filter_create(AuFilter* filter, ALHeap* heap);
void au_filter_init(AuFilter* filter, s16 arg1, s16 arg2, s16 fc);
void au_fx_load_preset(AuFX* fx, u8 effectType);
Acmd* au_pull_fx(AuFX* fx, Acmd* cmdBusPos, s16, s16);
s32 au_fx_param_hdl(AuFX* fx, s16 index, s16 paramID, s32 value);

#endif
