#include "common.h"
#include "model.h"
#include "ld_addrs.h"
#include "stdlib/stdarg.h"
#include "entity_script.h"

typedef struct GameMode {
    /* 0x00 */ u16 flags;
    /* 0x04 */ void (*init)(void);
    /* 0x08 */ void (*step)(void);
    /* 0x0C */ UNK_FUN_PTR(unk_0C);
    /* 0x10 */ void (*render)(void);
    /* 0x14 */ void (*renderAux)(void); ///< @see state_render_frontUI
} GameMode; // size = 0x18

typedef struct Fog {
    /* 0x00 */ s32 enabled;
    /* 0x04 */ s32 r;
    /* 0x08 */ s32 g;
    /* 0x0C */ s32 b;
    /* 0x10 */ s32 a;
    /* 0x14 */ s32 startDistance;
    /* 0x18 */ s32 endDistance;
} Fog; // size = 0x1C

extern s32 D_801516FC;

extern Gfx D_8014B7F8[];
extern Gfx D_8014B820[];
extern Gfx D_8014B848[];
extern Gfx D_8014B870[];
extern Gfx D_8014B898[];
extern Gfx D_8014B8C0[];
extern Gfx D_8014B8E8[];
extern Gfx D_8014B910[];
extern Gfx D_8014B938[];
extern Gfx D_8014B960[];
extern Gfx D_8014B988[];
extern Gfx D_8014B9B0[];
extern Gfx D_8014B9D8[];
extern Gfx D_8014BA00[];
extern Gfx D_8014BA20[];
extern Gfx D_8014BA48[];
extern Gfx D_8014BA70[];
extern Gfx D_8014BA98[];
extern Gfx D_8014BAC0[];
extern Gfx D_8014BAE8[];
extern Gfx D_8014BB10[];
extern Gfx D_8014BB38[];
extern Gfx D_8014BB60[];
extern Gfx D_8014BB88[];
extern Gfx D_8014BBB0[];
extern Gfx D_8014BBD8[];
extern Gfx D_8014BC00[];
extern Gfx D_8014BC28[];
extern Gfx D_8014BC50[];
extern Gfx D_8014BC78[];
extern Gfx D_8014BCA0[];
extern Gfx D_8014BCC8[];
extern Gfx D_8014BCF8[];
extern Gfx D_8014BD18[];
extern Gfx D_8014BD40[];
extern Gfx D_8014BD68[];
extern Gfx D_8014BD88[];
extern Gfx D_8014BDB0[];
extern Gfx D_8014BDD8[];
extern Gfx D_8014BE00[];
extern Gfx D_8014BE28[];
extern Gfx D_8014BE50[];
extern Gfx D_8014BE78[];
extern Gfx D_8014BEA0[];
extern Gfx D_8014BEC8[];
extern Gfx D_8014BEF0[];
extern Gfx D_8014BF18[];
extern Gfx D_8014BF40[];
extern Gfx D_8014BF68[];
extern Gfx D_8014BF90[];
extern Gfx D_8014BFB8[];
extern Gfx D_8014BFE0[];
extern Gfx D_8014C008[];
extern Gfx D_8014C028[];
extern Gfx D_8014C050[];
extern Gfx D_8014C078[];
extern Gfx D_8014C098[];
extern Gfx D_8014C0C0[];
extern Gfx D_8014C0E8[];
extern Gfx D_8014C110[];
extern Gfx D_8014C138[];
extern Gfx D_8014C160[];

s32 D_8014AFB0 = 0xFF;

s32 D_8014AFB4[] = {0, 0, 0};

Gfx* D_8014AFC0[] = { D_8014B7F8, D_8014B910, D_8014B820, D_8014B938, D_8014B848, D_8014B960, D_8014B870, D_8014B988, D_8014B898, D_8014BA20, D_8014B9B0, D_8014BAC0, D_8014B8C0, D_8014B9D8, D_8014B8E8, D_8014BA00, D_8014BB60, D_8014BC78, D_8014BB88, D_8014BCA0, D_8014BBB0, D_8014BCC8, D_8014BBD8, D_8014BCF8, D_8014BC00, D_8014BD88, D_8014BD18, D_8014BC28, D_8014BD40, D_8014BC50, D_8014BD68, D_8014BE78, D_8014BF90, D_8014BEA0, D_8014BFB8, D_8014BEC8, D_8014BFE0, D_8014BEF0, D_8014C008, D_8014BF18, D_8014C098, D_8014C028, D_8014BF40, D_8014C050, D_8014BF68, D_8014C078, D_8014BA48, D_8014BA70, D_8014BA98, D_8014BDB0, D_8014BDD8, D_8014BE00, D_8014C0C0, D_8014C0E8, D_8014C110, D_8014BB10, D_8014BB38, D_8014BE28, D_8014BE50, D_8014C138, D_8014C160, NULL };

Gfx D_8014B0B8[21][5] = {
    {
        gsDPSetCombineMode(G_CC_SHADE, G_CC_SHADE),
        gsDPSetCombineMode(G_CC_SHADE, G_CC_PASS2),
        gsDPSetCombineMode(G_CC_SHADE, G_CC_PASS2),
        gsDPSetCombineLERP(SHADE, 0, PRIMITIVE_ALPHA, PRIMITIVE, 0, 0, 0, SHADE, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(SHADE, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, SHADE, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
    }, {
        gsDPSetCombineMode(G_CC_MODULATEIA, G_CC_MODULATEIA),
        gsDPSetCombineMode(G_CC_MODULATEIDECALA, G_CC_PASS2),
        gsDPSetCombineMode(G_CC_MODULATEIA, G_CC_PASS2),
        gsDPSetCombineLERP(TEXEL0, 0, SHADE, 0, 0, 0, 0, TEXEL0, COMBINED, PRIMITIVE, PRIMITIVE_ALPHA, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, 0, SHADE, 0, TEXEL0, 0, SHADE, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    }, {
        gsDPSetCombineMode(G_CC_BLENDRGBA, G_CC_BLENDRGBA),
        gsDPSetCombineMode(G_CC_BLENDRGBA, G_CC_PASS2),
        gsDPSetCombineMode(G_CC_BLENDRGBA, G_CC_PASS2),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0_ALPHA, SHADE, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE_ALPHA, PRIMITIVE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0_ALPHA, SHADE, 0, 0, 0, SHADE, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_DECALRGBA),
        gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_PASS2),
        gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_PASS2),
        gsDPSetCombineLERP(TEXEL0, 0, PRIMITIVE_ALPHA, PRIMITIVE, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, TEXEL0, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, PRIMITIVE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, PRIMITIVE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, PRIMITIVE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, COMBINED, 0, SHADE, 0),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, COMBINED, 0, SHADE, 0),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, COMBINED, 0, SHADE, 0),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, COMBINED, 0, SHADE, 0),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, COMBINED, 0, SHADE, 0),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, COMBINED, 0, SHADE, 0),
    },
    {
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, 0, 0, 0, SHADE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, 0, 0, 0, SHADE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, 0, 0, 0, SHADE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, 0, 0, 0, SHADE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, SHADE, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, 1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
    },
    {
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
    },
    {
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
    },
    {
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
    },
};

Gfx D_8014B400[21][5] = {
    {
        gsDPSetCombineMode(G_CC_SHADE, G_CC_SHADE),
        gsDPSetCombineMode(G_CC_SHADE, G_CC_PASS2),
        gsDPSetCombineMode(G_CC_SHADE, G_CC_PASS2),
        gsDPSetCombineLERP(SHADE, 0, PRIMITIVE_ALPHA, PRIMITIVE, 0, 0, 0, SHADE, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(SHADE, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, SHADE, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_MODULATEIDECALA, G_CC_MODULATEIDECALA),
        gsDPSetCombineMode(G_CC_MODULATEIDECALA, G_CC_PASS2),
        gsDPSetCombineMode(G_CC_MODULATEIDECALA, G_CC_PASS2),
        gsDPSetCombineLERP(TEXEL0, 0, SHADE, 0, 0, 0, 0, TEXEL0, COMBINED, PRIMITIVE, PRIMITIVE_ALPHA, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, 0, SHADE, 0, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_BLENDRGBA, G_CC_BLENDRGBA),
        gsDPSetCombineMode(G_CC_BLENDRGBA, G_CC_PASS2),
        gsDPSetCombineMode(G_CC_BLENDRGBA, G_CC_PASS2),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0_ALPHA, SHADE, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE_ALPHA, PRIMITIVE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0_ALPHA, SHADE, 0, 0, 0, SHADE, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_DECALRGBA),
        gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_PASS2),
        gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_PASS2),
        gsDPSetCombineLERP(TEXEL0, 0, PRIMITIVE_ALPHA, PRIMITIVE, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, TEXEL0, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEI2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEI2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, PRIMITIVE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, PRIMITIVE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineMode(G_CC_TRILERP, G_CC_MODULATEIA2),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, SHADE, PRIMITIVE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, COMBINED, 0, SHADE, 0),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, SHADE, 0, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL1, 0, TEXEL0, 0, TEXEL1, 0, TEXEL0, 0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, 0, 0, 0, SHADE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, 0, 0, 0, SHADE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, 0, 0, 0, SHADE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, 0, 0, 0, SHADE, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(0, 0, 0, 0, TEXEL0, TEXEL1, SHADE, 0, SHADE, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(TEXEL0, TEXEL1, SHADE_ALPHA, TEXEL1, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0, 1, TEXEL1, TEXEL0, COMBINED, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, 1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, 0, 0, 0, COMBINED, 0, 0, 0, COMBINED),
        gsDPSetCombineLERP(1, TEXEL0, PRIMITIVE, TEXEL0, 0, 0, 0, TEXEL0, COMBINED, 0, PRIMITIVE, ENVIRONMENT, 0, 0, 0, COMBINED),
    },
    {
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
        gsDPSetCombineLERP(TEXEL0, SHADE, TEXEL0, TEXEL0, 1, TEXEL1, TEXEL0, TEXEL1, TEXEL0, COMBINED, TEXEL0_ALPHA, TEXEL0, 1, TEXEL0, TEXEL1, TEXEL0),
    },
    {
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
    },
    {
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
    },
    {
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
        gsDPSetCombineLERP(NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1, NOISE, 0, SHADE_ALPHA, 0, 0, 0, 0, 1),
    },
};

u32 mdl_textureBaseAddress = 0x8028E000;

u8 mdl_bgMultiplyColorA = 0;
u8 mdl_bgMultiplyColorR = 0;
u8 mdl_bgMultiplyColorG = 0;
u8 mdl_bgMultiplyColorB = 0;

s8 mdl_renderModelFogPrimColorR = 0;
s8 mdl_renderModelFogPrimColorG = 0;
s8 mdl_renderModelFogPrimColorB = 0;
s8 mdl_renderModelFogPrimColorA = 0;

s8 mdl_renderModelFogColorR = 0;
s8 mdl_renderModelFogColorG = 0;
s8 mdl_renderModelFogColorB = 0;
s8 mdl_renderModelFogColorA = 0; // unused?

s32 mdl_renderModelFogStart = 950;
s32 mdl_renderModelFogEnd = 1000;

s8 gRenderModelPrimR = 255;
s8 gRenderModelPrimG = 255;
s8 gRenderModelPrimB = 255;
s8 gRenderModelEnvR = 0;
s8 gRenderModelEnvG = 0;
s8 gRenderModelEnvB = 0;
s8 D_8014B766 = 0;
s8 D_8014B767 = 0;

Matrix4s mdl_RDPIdentity = {
    .whole = {
        {1, 0, 0, 0},
        {0, 1, 0, 0},
        {0, 0, 1, 0},
        {0, 0, 0, 1}
    },
    .frac = {
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0}
    }
};

s32 D_8014B7A8[] = { 0x00000006, 0x00000000, 0x00000005, 0x00020000, 0x00000004, 0x00030000, 0x00000003, 0x00038000, 0x00000002, 0x0003C000, 0x00000001, 0x0003E000, 0x00000000, 0x0003F000, 0x00000000, 0x0003F800, 0x00000000, 0x00000000, };

s32 D_8014B7F0 = 0;

// padding?
s32 D_8014B7F4 = 0;

Gfx D_8014B7F8[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_OPA_SURF, G_RM_AA_ZB_OPA_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD |
                          G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B820[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_OPA_DECAL, G_RM_AA_ZB_OPA_DECAL2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD |
                          G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B848[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_OPA_INTER, G_RM_AA_ZB_OPA_INTER2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD |
                          G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B870[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_TEX_EDGE, G_RM_AA_ZB_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B898[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_XLU_SURF, G_RM_AA_ZB_XLU_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B8C0[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_XLU_DECAL, G_RM_AA_ZB_XLU_DECAL2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B8E8[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_XLU_INTER, G_RM_AA_ZB_XLU_INTER2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B910[] = {
    gsDPSetRenderMode(G_RM_ZB_OPA_SURF, G_RM_ZB_OPA_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B938[] = {
    gsDPSetRenderMode(G_RM_ZB_OPA_DECAL, G_RM_ZB_OPA_DECAL2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B960[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_OPA_INTER, G_RM_AA_ZB_OPA_INTER2),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsDPSetCombineMode(G_CC_SHADE, G_CC_SHADE),
    gsSPEndDisplayList(),
};

Gfx D_8014B988[] = {
    gsDPSetRenderMode(G_RM_AA_ZB_TEX_EDGE, G_RM_AA_ZB_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B9B0[] = {
    gsDPSetRenderMode(G_RM_ZB_XLU_SURF, G_RM_ZB_XLU_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014B9D8[] = {
    gsDPSetRenderMode(G_RM_ZB_OVL_SURF, G_RM_ZB_OVL_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BA00[] = {
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BA20[] = {
    gsDPSetRenderMode(AA_EN | Z_CMP | Z_UPD | IM_RD | CLR_ON_CVG | CVG_DST_WRAP | ZMODE_XLU | FORCE_BL |
                      GBL_c1(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA), AA_EN | Z_CMP | Z_UPD | IM_RD |
                      CLR_ON_CVG | CVG_DST_WRAP | ZMODE_XLU | FORCE_BL |
                      GBL_c2(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BA48[] = {
    gsDPSetRenderMode(G_RM_AA_OPA_SURF, G_RM_AA_OPA_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BA70[] = {
    gsDPSetRenderMode(G_RM_AA_TEX_EDGE, G_RM_AA_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BA98[] = {
    gsDPSetRenderMode(G_RM_AA_XLU_SURF, G_RM_AA_XLU_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BAC0[] = {
    gsDPSetRenderMode(AA_EN | Z_CMP | Z_UPD | IM_RD | CLR_ON_CVG | CVG_DST_WRAP | ZMODE_XLU | FORCE_BL |
                      GBL_c1(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA), AA_EN | Z_CMP | Z_UPD | IM_RD |
                      CLR_ON_CVG | CVG_DST_WRAP | ZMODE_XLU | FORCE_BL |
                      GBL_c2(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BAE8[] = {
    gsDPSetRenderMode(IM_RD | CVG_DST_SAVE | ZMODE_XLU | FORCE_BL |
                      GBL_c1(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA), IM_RD | CVG_DST_SAVE | ZMODE_XLU |
                      FORCE_BL | GBL_c2(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BB10[] = {
    gsDPSetRenderMode(G_RM_ZB_CLD_SURF, G_RM_ZB_CLD_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BB38[] = {
    gsDPSetRenderMode(G_RM_CLD_SURF, G_RM_CLD_SURF2),
    gsDPSetCycleType(G_CYC_1CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BB60[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_OPA_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BB88[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_OPA_DECAL2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BBB0[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_OPA_INTER2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BBD8[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BC00[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_XLU_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BC28[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_XLU_DECAL2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BC50[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_XLU_INTER2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BC78[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_ZB_OPA_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BCA0[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_ZB_OPA_DECAL2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BCC8[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_OPA_INTER2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsDPSetCombineMode(G_CC_SHADE, G_CC_SHADE),
    gsSPEndDisplayList(),
};

Gfx D_8014BCF8[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BD18[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_ZB_XLU_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BD40[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_ZB_XLU_DECAL2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BD68[] = {
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BD88[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_ZB_XLU_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BDB0[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_OPA_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_CULL_BACK | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BDD8[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BE00[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_AA_XLU_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BE28[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_ZB_CLD_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BE50[] = {
    gsDPSetRenderMode(G_RM_PASS, G_RM_CLD_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BE78[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_OPA_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BEA0[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_OPA_DECAL2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BEC8[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_OPA_INTER2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BEF0[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BF18[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_XLU_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BF40[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_XLU_DECAL2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BF68[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_XLU_INTER2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BF90[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_ZB_OPA_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BFB8[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_ZB_OPA_DECAL2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014BFE0[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_OPA_INTER2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BACK | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C008[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C028[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_ZB_XLU_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C050[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_ZB_XLU_DECAL2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C078[] = {
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C098[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_ZB_XLU_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C0C0[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_OPA_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_CULL_BACK | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C0E8[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_TEX_EDGE2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C110[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_AA_XLU_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_ZBUFFER | G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_SHADE | G_FOG | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C138[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_ZB_CLD_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

Gfx D_8014C160[] = {
    gsDPSetRenderMode(G_RM_FOG_SHADE_A, G_RM_CLD_SURF2),
    gsDPSetCycleType(G_CYC_2CYCLE),
    gsSPClearGeometryMode(G_SHADE | G_CULL_BOTH | G_FOG | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD | G_SHADING_SMOOTH),
    gsSPSetGeometryMode(G_ZBUFFER | G_SHADE | G_LIGHTING | G_SHADING_SMOOTH),
    gsSPEndDisplayList(),
};

s32 mdl_renderTaskBasePriorities[RENDER_MODE_COUNT] = {
    [RENDER_MODE_SURF_SOLID_AA_ZB_LAYER0]   = -100000,
    [RENDER_MODE_SURFACE_OPA]               = 1000000,
    [RENDER_MODE_2]                         = 1000000,
    [RENDER_MODE_SURFACE_OPA_NO_AA]         = 1000000,
    [RENDER_MODE_SURFACE_OPA_NO_ZB]         =       0,
    [RENDER_MODE_DECAL_OPA]                 = 1000000,
    [RENDER_MODE_6]                         = 1000000,
    [RENDER_MODE_DECAL_OPA_NO_AA]           = 1000000,
    [RENDER_MODE_8]                         =       0,
    [RENDER_MODE_INTERSECTING_OPA]          = 1000000,
    [RENDER_MODE_A]                         = 1000000,
    [RENDER_MODE_B]                         = 1000000,
    [RENDER_MODE_C]                         =       0,
    [RENDER_MODE_ALPHATEST]                 = 1000000,
    [RENDER_MODE_E]                         = 1000000,
    [RENDER_MODE_ALPHATEST_ONESIDED]        = 1000000,
    [RENDER_MODE_ALPHATEST_NO_ZB]           =       0,
    [RENDER_MODE_SURFACE_XLU_LAYER1]        = 8000000,
    [RENDER_MODE_12]                        = 8000000,
    [RENDER_MODE_SURFACE_XLU_NO_AA]         = 8000000,
    [RENDER_MODE_SURFACE_XLU_NO_ZB]         =       0,
    [RENDER_MODE_SURFXLU_ZB_ZUPD]           = 8000000,
    [RENDER_MODE_SURFACE_XLU_LAYER2]        = 7500000,
    [RENDER_MODE_17]                        = 7500000,
    [RENDER_MODE_18]                        = 7500000,
    [RENDER_MODE_19]                        =       0,
    [RENDER_MODE_DECAL_XLU]                 = 7000000,
    [RENDER_MODE_1B]                        = 7000000,
    [RENDER_MODE_DECAL_XLU_NOAA]            = 7000000,
    [RENDER_MODE_1D]                        = 7000000,
    [RENDER_MODE_1E]                        = 6500000,
    [RENDER_MODE_1F]                        = 6500000,
    [RENDER_MODE_SHADOW]                    = 6500000,
    [RENDER_MODE_21]                        =       0,
    [RENDER_MODE_SURFACE_XLU_LAYER3]        = 6000000,
    [RENDER_MODE_23]                        = 6000000,
    [RENDER_MODE_24]                        = 6000000,
    [RENDER_MODE_25]                        =       0,
    [RENDER_MODE_INTERSECTING_XLU]          = 5500000,
    [RENDER_MODE_27]                        = 5500000,
    [RENDER_MODE_28]                        = 5500000,
    [RENDER_MODE_SURFXLU_AA_ZB_ZUPD]        = 8000000,
    [RENDER_MODE_2A]                        = 4000000,
    [RENDER_MODE_2B]                        = 4250000,
    [RENDER_MODE_2C]                        = 4500000,
    [RENDER_MODE_2D]                        = 4500000,
    [RENDER_MODE_CLOUD]                     = 8000000,
    [RENDER_MODE_CLOUD_NO_ZB]               =  700000,
};


s8 D_8014C248[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };

// BSS
extern s32 B_801512B0[2];
extern ModelCustomGfxBuilderList* gCurrentCustomModelGfxBuildersPtr;
extern s32 D_801512BC;
extern s32 entity_numEntities;
extern s32 gEntityHeapBase;
extern s32 gHudElementCacheTableRaster;
extern ModelList* gCurrentModels;
extern s32 gHudElementCacheTablePalette[4];
extern ModelNode** gCurrentModelTreeRoot;
extern ModelTransformGroupList* gCurrentTransformGroups;
extern s8 gMsgGlobalWaveCounter[0x4];
extern ModelCustomGfxList* gCurrentCustomModelGfxPtr;
extern s32 gLastCreatedEntityIndex;
extern s8 B_801512F0[0x410];
extern GameMode gMainGameState[2]; // TODO rename

extern s32 gEntityHeapBottom;
extern s32 entity_numShadows;
extern s32 D_8015132C;
extern s32 entity_updateCounter;

extern s32 wEntityBlueprintSize;
extern s32 bEntityBlueprintSize;

extern EntityBlueprint* wEntityBlueprint[30];
extern EntityBlueprint* bEntityBlueprint[4];

extern s32* D_801516F4;

extern TileDescriptor gCurrentTileDescriptor;

extern ModelList wModelList;
extern ModelList bModelList;

extern ModelTransformGroupList wTransformGroups;
extern ModelTransformGroupList bTransformGroups;

extern ModelCustomGfxList wModelSpecialDls;
extern ModelCustomGfxList bModelSpecialDls;

extern ModelCustomGfxBuilderList wCustomModelGfxBuilders;
extern ModelCustomGfxBuilderList bCustomModelGfxBuilders;
extern ModelLocalVertexCopyList wModelLocalVtxBuffers;
extern ModelLocalVertexCopyList bModelLocalVtxBuffers;
extern ModelLocalVertexCopyList* gCurrentModelLocalVtxBuffers;

extern ModelNode* D_80152214;
extern ModelNode* D_80152218;
extern ModelTreeInfoList D_80152220;
extern ModelTreeInfoList D_80152A20;

extern s8 wBgRenderType;
extern s8 bBgRenderType;
extern s32 mdl_treeIterPos;
extern Fog wFogSettings;
extern Fog bFogSettings;
extern Fog* gCurrentFogSettings;
extern s32 texPannerMainU[MAX_TEX_PANNERS];
extern s32 texPannerMainV[MAX_TEX_PANNERS];
extern s32 texPannerAuxU[MAX_TEX_PANNERS];
extern s32 texPannerAuxV[MAX_TEX_PANNERS];
extern u32 mdl_nextTextureAddress;
extern u16 mdl_currentTransformGroupChildIndex;
extern u16 D_80153226;
extern ModelNode* D_80153370;
extern u16 D_80153374;
extern u16 D_80153376;
extern u16 D_8015336E;
extern RenderTask* mdl_renderTaskLists[3];
extern s32 mdl_renderTaskQueueIdx;
extern s32 mdl_renderTaskCount;

extern TextureHandle mdl_textureHandles[128];
extern RenderTask mdl_clearRenderTasks[3][0x100];

extern s32 D_801A7000; // todo ???

void update_shadows(void);
s32 step_entity_commandlist(Entity* entity);
void render_shadows(void);
void update_entity_transform_matrix(Entity* entity);
void update_shadow_transform_matrix(Shadow* shadow);
void update_entity_inverse_rotation_matrix(Entity* entity);
void delete_entity(s32 entityIndex);
void delete_entity_and_unload_data(s32 entityIndex);
void _delete_shadow(s32 shadowIndex);
void func_80110F10(void);
s32 entity_get_collision_flags(Entity* entity);
void entity_free_static_data(EntityBlueprint* data);
s32 create_entity_shadow(Entity* entity, f32 x, f32 y, f32 z);
void update_entity_shadow_position(Entity* entity);
void func_80117D00(Model* model);
void appendGfx_model_group(Model* model);
void render_transform_group_node(ModelNode* node);
void render_transform_group(ModelTransformGroup* group);
void load_model_transforms(ModelNode* model, ModelNode* parent, Matrix4f mdlTxMtx, s32 treeDepth);
void enable_transform_group(u16 modelID);

void update_entities(void) {
    s32 i;

    D_801512BC = 0;
    entity_numEntities = 0;
    entity_updateCounter++;

    for (i = 0; i < MAX_ENTITIES; i++) {
        Entity* entity = get_entity_by_index(i);

        if (entity != NULL) {
            entity_numEntities++;

            if (!(entity->flags & ENTITY_FLAGS_SKIP_UPDATE)) {
                if (entity->flags & ENTITY_FLAGS_BOUND_SCRIPT_DIRTY) {
                    entity->flags &= ~ENTITY_FLAGS_BOUND_SCRIPT_DIRTY;
                    if (!(entity->flags & ENTITY_FLAGS_8000)) {
                        entity->flags |= ENTITY_FLAGS_2000000;
                    }
                    entity->boundScript = start_script(entity->boundScriptBytecode, EVT_PRIORITY_A, EVT_FLAG_20);
                }

                if (entity->flags & ENTITY_FLAGS_2000000) {
                    if (does_script_exist(entity->boundScript->id)) {
                        if (entity->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
                            update_model_animator(entity->virtualModelIndex);
                        } else {
                            exec_entity_model_commandlist(entity->virtualModelIndex);
                        }

                        if (entity->flags & ENTITY_FLAGS_ALWAYS_FACE_CAMERA) {
                            entity->rotation.y = -gCameras[gCurrentCameraID].currentYaw;
                        }

                        if (!(entity->flags & ENTITY_FLAGS_SKIP_UPDATE_TRANSFORM_MATRIX)) {
                            update_entity_transform_matrix(entity);
                        }
                        continue;
                    } else {
                        entity->flags &= ~ENTITY_FLAGS_2000000;
                    }
                }

                if (entity->collisionTimer == 0) {
                    entity->collisionFlags = entity_get_collision_flags(entity);

                    if (entity->collisionFlags) {
                        EntityCallback handleCollision = entity->blueprint->fpHandleCollision;

                        if (handleCollision != NULL && handleCollision(entity) != 0) {
                            entity->collisionTimer = 10;
                            entity->flags |= ENTITY_FLAGS_DETECTED_COLLISION;
                        }
                    }
                } else {
                    entity->collisionTimer--;
                    if (entity->flags & ENTITY_FLAGS_CONTINUOUS_COLLISION) {
                        if (entity->collisionTimer == 0) {
                            entity->flags &= ~(ENTITY_FLAGS_SKIP_UPDATE_INVERSE_ROTATION_MATRIX | ENTITY_FLAGS_CONTINUOUS_COLLISION);
                        } else {
                            entity->flags |= ENTITY_FLAGS_SKIP_UPDATE_INVERSE_ROTATION_MATRIX;
                        }
                    } else if (entity->collisionTimer == 0) {
                        entity->flags &= ~ENTITY_FLAGS_DETECTED_COLLISION;
                        entity->flags &= ~ENTITY_FLAGS_BLOCK_BEING_HIT;
                        entity->collisionFlags = 0;
                    }
                }

                if (entity->flags & ENTITY_FLAGS_ALWAYS_FACE_CAMERA) {
                    entity->rotation.y = -gCameras[gCurrentCameraID].currentYaw;
                }

                if (!gGameStatusPtr->disableScripts) {
                    if (entity->updateScriptCallback != NULL) {
                        entity->updateScriptCallback(entity);
                    }

                    if (entity->scriptReadPos != NULL) {
                        if (entity->scriptDelay != 0) {
                            entity->scriptDelay--;
                            if (entity->scriptDelay == 0) {
                                while (step_entity_commandlist(entity));
                            }
                        }
                    }
                }

                if (!(entity->flags & ENTITY_FLAGS_SKIP_UPDATE_TRANSFORM_MATRIX)) {
                    update_entity_transform_matrix(entity);
                }

                if (!(entity->flags & ENTITY_FLAGS_SKIP_UPDATE_INVERSE_ROTATION_MATRIX)) {
                    update_entity_inverse_rotation_matrix(entity);
                }

                if (entity->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
                    update_model_animator(entity->virtualModelIndex);
                } else {
                    exec_entity_model_commandlist(entity->virtualModelIndex);
                }

                if (entity->shadowIndex >= 0) {
                    update_entity_shadow_position(entity);
                }

                if (entity->flags & ENTITY_FLAGS_PENDING_INSTANCE_DELETE) {
                    delete_entity(entity->listIndex);
                }

                if (entity->flags & ENTITY_FLAGS_PENDING_FULL_DELETE) {
                    delete_entity_and_unload_data(entity->listIndex);
                }
            }
        }
    }

    update_shadows();
    D_8015A578.unk_00 = FALSE;
}

void update_shadows(void) {
    s32 i;

    entity_numShadows = 0;

    for (i = 0; i < MAX_SHADOWS; i++) {
        Shadow* shadow = get_shadow_by_index(i);

        if (shadow != NULL) {
            entity_numShadows++;

            if (!(shadow->flags & SHADOW_FLAGS_40000000)) {
                if (shadow->flags & SHADOW_FLAGS_ALIGNED_TO_CAMERA) {
                    shadow->rotation.y = -gCameras[gCurrentCameraID].currentYaw;
                }

                update_shadow_transform_matrix(shadow);

                if (shadow->flags & SHADOW_FLAGS_COMPLEX_MODEL) {
                    update_model_animator(shadow->entityModelID);
                } else {
                    exec_entity_model_commandlist(shadow->entityModelID);
                }

                if (shadow->flags & SHADOW_FLAGS_READY_TO_DELETE) {
                    _delete_shadow(shadow->listIndex);
                }
            }
        }
    }
}

void set_entity_commandlist(Entity* entity, s32* entityScript) {
    entity->scriptReadPos = entityScript;
    entity->scriptDelay = TRUE;
    entity->savedReadPos[0] = entity->scriptReadPos;
}

s32 step_entity_commandlist(Entity* entity) {
    s32* args = entity->scriptReadPos;
    s32 ret;
    s32 labelId;
    s32 (*tempfunc)(Entity*);

    switch (*args++) {
        case ENTITY_SCRIPT_OP_End:
            entity->scriptDelay = -1;
            entity->updateScriptCallback = NULL;
            entity->scriptReadPos = NULL;
            ret = FALSE;
            break;
        case ENTITY_SCRIPT_OP_Jump:
            entity->scriptReadPos = *args;
            entity->scriptDelay = 1;
            entity->savedReadPos[0] = entity->scriptReadPos;
            ret = TRUE;
            break;
        case ENTITY_SCRIPT_OP_Call:
            tempfunc = *args++;
            entity->scriptReadPos = args;
            (tempfunc)(entity);
            ret = TRUE;
            break;
        case ENTITY_SCRIPT_OP_SetCallback:
            entity->scriptDelay = *args++;
            entity->updateScriptCallback = (s32 (*)(Entity*)) *args++;
            entity->scriptReadPos = args++;
            ret = FALSE;
            break;
        case ENTITY_SCRIPT_OP_Goto:
            entity->scriptReadPos = entity->savedReadPos[*args];
            ret = TRUE;
            break;
        case ENTITY_SCRIPT_OP_Label:
            labelId = *args++;
            entity->savedReadPos[labelId] = args;
            entity->scriptReadPos = args;
            ret = TRUE;
            break;
        case ENTITY_SCRIPT_OP_RestartBoundScript:
            if (entity->boundScriptBytecode != NULL) {
                entity->flags |= ENTITY_FLAGS_BOUND_SCRIPT_DIRTY;
            }
            entity->scriptReadPos = args++;
            ret = TRUE;
            break;
        case ENTITY_SCRIPT_OP_SetFlags:
            entity->flags |= *args++;
            entity->scriptReadPos = args++;
            ret = TRUE;
            break;
        case ENTITY_SCRIPT_OP_ClearFlags:
            entity->flags &= ~*args++;
            entity->scriptReadPos = args++;
            ret = TRUE;
            break;
        case ENTITY_SCRIPT_OP_PlaySound:
            sfx_play_sound(*args++);
            entity->scriptReadPos = args++;
            ret = TRUE;
            break;
        default:
            args++;
            entity->scriptReadPos = args++;
            ret = TRUE;
            break;
    }
    return ret;
}

void exec_entity_commandlist(Entity* entity) {
    while (step_entity_commandlist(entity));
}

void func_8010FD98(void* arg0, s32 alpha) {
    if (alpha >= 255) {
        gDPSetRenderMode(gMasterGfxPos++, G_RM_AA_ZB_OPA_SURF, G_RM_AA_ZB_OPA_SURF2);
        gDPSetCombineMode(gMasterGfxPos++, G_CC_MODULATEIA, G_CC_MODULATEIA);
    } else {
        gDPSetCombineLERP(gMasterGfxPos++, 0, 0, 0, TEXEL0, PRIMITIVE, 0, TEXEL0, 0, 0, 0, 0, TEXEL0, TEXEL0, 0, PRIMITIVE, 0);
        gDPSetPrimColor(gMasterGfxPos++, 0, 0, 0x00, 0x00, 0x00, alpha);
    }
}

void func_8010FE44(void* arg0) {
    func_8010FD98(arg0, D_8014AFB0);
}

void entity_model_set_shadow_color(void* data) {
    s32 alpha = (s32)data;

    gDPSetCombineLERP(gMasterGfxPos++, 0, 0, 0, 0, PRIMITIVE, 0, TEXEL0, 0, 0, 0, 0, 0, TEXEL0, 0, PRIMITIVE, 0);
    gDPSetPrimColor(gMasterGfxPos++, 0, 0, 0x00, 0x00, 0x00, alpha);
}

void render_entities(void) {
    s32 i;

    for (i = 0; i < MAX_ENTITIES; i++) {
        Entity* entity = get_entity_by_index(i);

        if (entity != NULL) {
            if (!gGameStatusPtr->isBattle) {
                if (gEntityHideMode != 0 &&
                    !(entity->flags & ENTITY_FLAGS_IGNORE_DISTANCE_CULLING) &&
                    dist2D(gPlayerStatusPtr->position.x,
                           gPlayerStatusPtr->position.z,
                           entity->position.x,
                           entity->position.z) > 200.0f
                   ) {
                    continue;
                }

                if (gEntityHideMode == 1) {
                    if (!(entity->flags & ENTITY_FLAGS_DRAW_IF_CLOSE_HIDE_MODE1)) {
                        continue;
                    }
                } else if (gEntityHideMode == 2) {
                    if (!(entity->flags & ENTITY_FLAGS_DRAW_IF_CLOSE_HIDE_MODE2)) {
                        continue;
                    }
                }
            }

            if (!(entity->flags & ENTITY_FLAGS_HIDDEN)) {
                if (entity->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
                    if (D_8014AFB0 == 0xFF) {
                        if (entity->renderSetupFunc != NULL) {
                            set_animator_render_callback(entity->virtualModelIndex, entity->listIndex, entity->renderSetupFunc);
                        }
                    } else {
                        set_animator_render_callback(entity->virtualModelIndex, entity->listIndex, func_8010FE44);
                    }

                    if (entity->vertexData == NULL) {
                        render_animated_model(entity->virtualModelIndex, &entity->transformMatrix);
                    } else {
                        render_animated_model_with_vertices(entity->virtualModelIndex,
                                      &entity->transformMatrix,
                                      entity->vertexSegment,
                                      entity->vertexData);
                    }
                } else {
                    if (D_8014AFB0 == 0xFF) {
                        if (entity->renderSetupFunc != NULL) {
                            bind_entity_model_setupGfx(entity->virtualModelIndex,
                                                       entity->listIndex,
                                                       entity->renderSetupFunc);
                        } else {
                            get_entity_model(entity->virtualModelIndex)->fpSetupGfxCallback = NULL;
                        }
                    } else {
                        bind_entity_model_setupGfx(entity->virtualModelIndex, entity->listIndex, func_8010FE44);
                    }

                    if (entity->vertexData == NULL) {
                        draw_entity_model_A(entity->virtualModelIndex, &entity->transformMatrix);
                    } else {
                        draw_entity_model_B(entity->virtualModelIndex,
                                               &entity->transformMatrix,
                                               entity->vertexSegment,
                                               entity->vertexData);
                    }
                }
            }
        }
    }

    render_shadows();
}

void render_shadows(void) {
    s32 i;

    for (i = 0; i < MAX_SHADOWS; i++) {
        Shadow* shadow = get_shadow_by_index(i);

        if (shadow != NULL) {
            if (shadow->flags & SHADOW_FLAGS_HIDDEN) {
                if (shadow->flags & SHADOW_FLAGS_FADING_AWAY) {
                    shadow->alpha -= 20;
                    if (shadow->alpha <= 20) {
                        shadow->flags |= SHADOW_FLAGS_READY_TO_DELETE;
                    }
                }
            } else if (shadow->flags & SHADOW_FLAGS_COMPLEX_MODEL) {
                if (shadow->vertexArray == NULL) {
                    render_animated_model(shadow->entityModelID, &shadow->transformMatrix);
                } else {
                    render_animated_model_with_vertices(shadow->entityModelID,
                                  &shadow->transformMatrix,
                                  shadow->vertexSegment,
                                  shadow->vertexArray);
                }
            } else {
                if (shadow->flags & SHADOW_FLAGS_FADING_AWAY) {
                    shadow->alpha -= 20;
                    if (shadow->alpha <= 20) {
                        shadow->flags |=  SHADOW_FLAGS_READY_TO_DELETE;
                    }
                }

                bind_entity_model_setupGfx(shadow->entityModelID, shadow->alpha, entity_model_set_shadow_color);

                if (shadow->vertexArray == NULL) {
                    draw_entity_model_A(shadow->entityModelID, &shadow->transformMatrix);
                } else {
                    draw_entity_model_B(shadow->entityModelID,
                                           &shadow->transformMatrix,
                                           shadow->vertexSegment,
                                           shadow->vertexArray);
                }
            }
        }
    }
}

void update_entity_transform_matrix(Entity* entity) {
    Matrix4f sp18;
    Matrix4f sp58;
    Matrix4f sp98;
    Matrix4f spD8;
    Matrix4f sp118;
    Matrix4f sp158;
    Matrix4f sp198;

    if (entity->updateMatrixOverride != NULL) {
        entity->updateMatrixOverride(entity);
        return;
    }

    guTranslateF(sp58, entity->position.x, entity->position.y, entity->position.z);
    guRotateF(spD8, entity->rotation.x, 1.0f, 0.0f, 0.0f);
    guRotateF(sp118, entity->rotation.y, 0.0f, 1.0f, 0.0f);
    guRotateF(sp158, entity->rotation.z, 0.0f, 0.0f, 1.0f);
    guMtxCatF(sp158, spD8, sp18);
    guMtxCatF(sp18, sp118, sp98);
    guScaleF(sp198, entity->scale.x, entity->scale.y, entity->scale.z);
    guMtxCatF(sp198, sp98, sp18);
    guMtxCatF(sp18, sp58, sp98);
    guMtxF2L(sp98, &entity->transformMatrix);
}

void update_shadow_transform_matrix(Shadow* shadow) {
    Matrix4f sp18;
    Matrix4f sp58;
    Matrix4f sp98;
    Matrix4f spD8;
    Matrix4f sp118;
    Matrix4f sp158;
    Matrix4f sp198;

    guTranslateF(sp58, shadow->position.x, shadow->position.y, shadow->position.z);
    guRotateF(sp118, shadow->rotation.x, 1.0f, 0.0f, 0.0f);
    guRotateF(spD8, shadow->rotation.y, 0.0f, 1.0f, 0.0f);
    guRotateF(sp158, shadow->rotation.z, 0.0f, 0.0f, 1.0f);
    guMtxCatF(sp158, sp118, sp98);
    guMtxCatF(spD8, sp98, sp98);
    guScaleF(sp198, shadow->scale.x, shadow->scale.y, shadow->scale.z);
    guMtxCatF(sp198, sp98, sp18);
    guMtxCatF(sp18, sp58, sp98);
    guMtxF2L(sp98, &shadow->transformMatrix);
}

void update_entity_inverse_rotation_matrix(Entity* entity) {
    Matrix4f sp18;
    Matrix4f sp58;

    guRotateF(sp18, -entity->rotation.y, 0.0f, 1.0f, 0.0f);
    guRotateF(sp58, -entity->rotation.z, 0.0f, 0.0f, 1.0f);
    guMtxCatF(sp18, sp58, sp18);
    guRotateF(sp58, -entity->rotation.x, 1.0f, 0.0f, 0.0f);
    guMtxCatF(sp18, sp58, entity->inverseTransformMatrix);

    entity->effectiveSize = sqrtf(((SQ(entity->aabb.x) + SQ(entity->aabb.z)) * 0.25f) + SQ(entity->aabb.y));
}

Entity* get_entity_by_index(s32 index) {
    return (*gCurrentEntityListPtr)[index & 0xFFF];
}

Shadow* get_shadow_by_index(s32 index) {
    return (*gCurrentShadowListPtr)[index & 0xFFF];
}

EntityList* get_entity_list(void) {
    EntityList* ret;

    if (!gGameStatusPtr->isBattle) {
        ret = &gWorldEntityList;
    } else {
        ret = &gBattleEntityList;
    }
    return ret;
}

ShadowList* get_shadow_list(void) {
    ShadowList* ret;

    if (!gGameStatusPtr->isBattle) {
        ret = &gWorldShadowList;
    } else {
        ret = &gBattleShadowList;
    }
    return ret;
}

s32 entity_start_script(Entity* entity) {
    if (entity->boundScriptBytecode != NULL) {
        entity->flags |= ENTITY_FLAGS_BOUND_SCRIPT_DIRTY;
        return 1;
    }
    return 0;
}

u32 get_entity_type(s32 index) {
    Entity* entity = get_entity_by_index(index);

    if (entity == NULL) {
        return -1;
    } else {
        return entity->blueprint->entityType;
    }
}

void delete_entity(s32 entityIndex) {
    Entity* entity = get_entity_by_index(entityIndex);

    if (entity->dataBuf.any != NULL) {
        heap_free(entity->dataBuf.any);
    }

    if (!(entity->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL)) {
        free_entity_model_by_index(entity->virtualModelIndex);
    } else {
        delete_model_animator(get_animator_by_index(entity->virtualModelIndex));
    }

    if (entity->shadowIndex >= 0) {
        Shadow* shadow = get_shadow_by_index(entity->shadowIndex);

        shadow->flags |= SHADOW_FLAGS_FADING_AWAY;
    }

    heap_free((*gCurrentEntityListPtr)[entityIndex]);
    (*gCurrentEntityListPtr)[entityIndex] = NULL;
}

void delete_entity_and_unload_data(s32 entityIndex) {
    Entity* entity = get_entity_by_index(entityIndex);

    if (entity->dataBuf.any != NULL) {
        heap_free(entity->dataBuf.any);
    }

    if (!(entity->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL)) {
        free_entity_model_by_index(entity->virtualModelIndex);
    } else {
        delete_model_animator(get_animator_by_index(entity->virtualModelIndex));
    }

    entity_free_static_data(entity->blueprint);

    if (entity->shadowIndex >= 0) {
        Shadow* shadow = get_shadow_by_index(entity->shadowIndex);

        shadow->flags |= SHADOW_FLAGS_FADING_AWAY;
    }

    heap_free((*gCurrentEntityListPtr)[entityIndex]);
    (*gCurrentEntityListPtr)[entityIndex] = NULL;
}

void _delete_shadow(s32 shadowIndex) {
    Shadow* shadow = get_shadow_by_index(shadowIndex);

    free_entity_model_by_index(shadow->entityModelID);
    heap_free((*gCurrentShadowListPtr)[shadowIndex]);
    (*gCurrentShadowListPtr)[shadowIndex] = NULL;
}

s32 entity_get_collision_flags(Entity* entity) {
    u32 listIndex = entity->listIndex;
    s32 entityFlags = 0;
    u32 flag;

    if (entity->flags & ENTITY_FLAGS_BLOCK_BEING_HIT) {
        entityFlags = ENTITY_COLLISION_BLOCK_HIT;
        entity->flags &= ~ENTITY_FLAGS_BLOCK_BEING_HIT;
    }

    flag = gCollisionStatus.currentFloor;
    if (flag != -1 && (flag & COLLISION_WITH_ENTITY_BIT) && listIndex == (u8)flag) {
        entityFlags |= ENTITY_COLLISION_PLAYER_TOUCH_FLOOR;
    }

    flag = gCollisionStatus.lastTouchedFloor;
    if (flag != -1 && (flag & COLLISION_WITH_ENTITY_BIT) && listIndex == (u8)flag) {
        entityFlags |= ENTITY_COLLISION_PLAYER_LAST_FLOOR;
    }

    flag = gCollisionStatus.currentCeiling;
    if (flag != -1 && (flag & COLLISION_WITH_ENTITY_BIT) && listIndex == (u8)flag) {
        entityFlags |= ENTITY_COLLISION_PLAYER_TOUCH_CEILING;
    }

    flag = gCollisionStatus.pushingAgainstWall;
    if (flag != -1 && (flag & COLLISION_WITH_ENTITY_BIT) && listIndex == (u8)flag) {
        entityFlags |= ENTITY_COLLISION_PLAYER_PUSHING_AGAINST;
    }

    flag = gCollisionStatus.lastWallHammered;
    if (flag != -1 && (flag & COLLISION_WITH_ENTITY_BIT) && listIndex == (u8)flag) {
        entityFlags |= ENTITY_COLLISION_PLAYER_HAMMER;
    }

    flag = gCollisionStatus.currentWall;
    if (flag != -1 && (flag & COLLISION_WITH_ENTITY_BIT) && listIndex == (u8)flag && gPlayerStatusPtr->pressedButtons & BUTTON_A) {
        entityFlags |= ENTITY_COLLISION_PLAYER_TOUCH_WALL;
    }

    return entityFlags;
}

s32 entity_interacts_with_current_partner(s32 entityIdx) {
    s32 ret = FALSE;
    u32 entityType = get_entity_type(entityIdx);
    s32 partnerID = get_current_partner_id();
    Entity* entity;

    switch (partnerID) {
        case PARTNER_BOMBETTE:
            switch (entityType) {
                default:
                    return FALSE;
                case ENTITY_TYPE_BLUE_SWITCH:
                case ENTITY_TYPE_RED_SWITCH:
                case ENTITY_TYPE_MULTI_TRIGGER_BLOCK:
                case ENTITY_TYPE_BRICK_BLOCK:
                case ENTITY_TYPE_MULTI_COIN_BRICK:
                case ENTITY_TYPE_YELLOW_BLOCK:
                case ENTITY_TYPE_SINGLE_TRIGGER_BLOCK:
                case ENTITY_TYPE_HIDDEN_YELLOW_BLOCK:
                case ENTITY_TYPE_HIDDEN_RED_BLOCK:
                case ENTITY_TYPE_RED_BLOCK:
                case ENTITY_TYPE_HAMMER1_BLOCK:
                case ENTITY_TYPE_HAMMER1_BLOCK_TINY:
                case ENTITY_TYPE_SUPER_BLOCK:
                case ENTITY_TYPE_BOMBABLE_ROCK:
                    entity = get_entity_by_index(entityIdx);
                    entity->flags |= ENTITY_FLAGS_BLOCK_BEING_HIT;
                    ret = TRUE;
            }
            break;
        case PARTNER_KOOPER:
             switch (entityType) {
                default:
                    return FALSE;
                case ENTITY_TYPE_BLUE_SWITCH:
                case ENTITY_TYPE_RED_SWITCH:
                case ENTITY_TYPE_MULTI_TRIGGER_BLOCK:
                case ENTITY_TYPE_BRICK_BLOCK:
                case ENTITY_TYPE_MULTI_COIN_BRICK:
                case ENTITY_TYPE_YELLOW_BLOCK:
                case ENTITY_TYPE_SINGLE_TRIGGER_BLOCK:
                case ENTITY_TYPE_HIDDEN_YELLOW_BLOCK:
                case ENTITY_TYPE_HIDDEN_RED_BLOCK:
                case ENTITY_TYPE_RED_BLOCK:
                case ENTITY_TYPE_HEALING_BLOCK:
                case ENTITY_TYPE_1C:
                case ENTITY_TYPE_SAVE_POINT:
                case ENTITY_TYPE_SUPER_BLOCK:
                    entity = get_entity_by_index(entityIdx);
                    entity->flags |= ENTITY_FLAGS_BLOCK_BEING_HIT;
                    ret = TRUE;
            }
            break;
    }
    return ret;
}

s32 test_player_entity_aabb(Entity* entity) {
    f32 yTemp = entity->position.y - (gPlayerStatus.position.y + gPlayerStatus.colliderHeight);
    f32 xCollRadius;
    f32 zCollRadius;
    f32 xDist;
    f32 zDist;

    if (yTemp > 0.0f || gPlayerStatus.colliderHeight + entity->aabb.y < fabsf(yTemp)) {
        return 0;
    }

    xCollRadius = (gPlayerStatus.colliderDiameter + entity->aabb.x) * 0.5;
    xDist = fabsf(gPlayerStatus.position.x - entity->position.x);
    zCollRadius = ((gPlayerStatus.colliderDiameter + entity->aabb.z) * 0.5);
    zDist = fabsf(gPlayerStatus.position.z - entity->position.z);

    if (xCollRadius < xDist || zCollRadius < zDist) {
        return 0;
    }

    return 1;
}

s32 is_player_action_state(s8 actionState) {
    return actionState == gPlayerStatus.actionState;
}

void entity_set_render_script(Entity* entity, u32* commandList) {
    if (!(entity->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL)) {
        set_entity_model_render_command_list(entity->virtualModelIndex, commandList);
    }
}

void func_80110BF8(Entity* entity) {
    entity->collisionTimer = 0;
    entity->flags &= ~ENTITY_FLAGS_DETECTED_COLLISION;
}

#ifdef NON_MATCHING
#define AREA_SPECIFIC_ENTITY_VRAM &entity_default_VRAM
#else
#define AREA_SPECIFIC_ENTITY_VRAM 0x802BAE00
#endif

void load_area_specific_entity_data(void) {
    if (D_8015132C == 0) {
        if (gGameStatusPtr->areaID == AREA_JAN || gGameStatusPtr->areaID == AREA_IWA) {
            dma_copy(entity_jan_iwa_ROM_START, entity_jan_iwa_ROM_END, (void*)AREA_SPECIFIC_ENTITY_VRAM);
        } else if (gGameStatusPtr->areaID == AREA_SBK || gGameStatusPtr->areaID == AREA_OMO) {
            dma_copy(entity_sbk_omo_ROM_START, entity_sbk_omo_ROM_END, (void*)AREA_SPECIFIC_ENTITY_VRAM);
        } else {
            dma_copy(entity_default_ROM_START, entity_default_ROM_END, (void*)AREA_SPECIFIC_ENTITY_VRAM);
        }

        D_8015132C = 1;
    }
}

extern s32 D_80151304;
extern s32 D_80151344;

void clear_entity_data(s32 arg0) {
    s32 i;

    D_801516FC = 1;
    entity_numEntities = 0;
    entity_numShadows = 0;
    entity_updateCounter = 0;
    D_80151304 = 0;

    if (!gGameStatusPtr->isBattle) {
        gEntityHideMode = 0;
    }

    D_8015132C = 0;
    D_8015A578.unk_01 = 0;
    D_8015A578.unk_02 = FALSE;
    if (!arg0) {
        D_80151344 = 0;
    }
    D_8014AFB0 = 0xFF;

    if (!gGameStatusPtr->isBattle) {
        wEntityBlueprintSize = 0;
        for (i = 0; i < 30; i++) {
            wEntityBlueprint[i] = NULL;
        }
    } else {
        bEntityBlueprintSize = 0;
        for (i = 0; i < 4; i++) {
            bEntityBlueprint[i] = NULL;
        }
    }

    if (!gGameStatusPtr->isBattle) {
        gEntityHeapBottom = 0x80250000;
        gEntityHeapBase = 0x80267FF0;
    } else {
        gEntityHeapBottom = &D_801A7000;
        gEntityHeapBase = gEntityHeapBottom + 0x3000;
    }

    gCurrentEntityListPtr = get_entity_list();
    gCurrentShadowListPtr = get_shadow_list();

    for (i = 0; i < 30; i++) {
        (*gCurrentEntityListPtr)[i] = NULL;
    }

    for (i = 0; i < 60; i++) {
        (*gCurrentShadowListPtr)[i] = NULL;
    }
}

void func_80110E58(void) {
    if (!gGameStatusPtr->isBattle) {
        gEntityHeapBottom = 0x80250000;
        gEntityHeapBase = 0x80267FF0;
        func_80110F10();
    } else {
        s32 i;

        for (i = 0; i < 4; i++) {
            bEntityBlueprint[i] = 0;
        }
        gEntityHeapBottom = &D_801A7000;
        gEntityHeapBase = gEntityHeapBottom + 0x3000;
    }
    gCurrentEntityListPtr = get_entity_list();
    gCurrentShadowListPtr = get_shadow_list();
    entity_numEntities = 0;
    entity_numShadows = 0;
}

void func_80110F10(void) {
    s32 i;
    s32 totalSize = 0;
    s32 temp1;
    s32 dataLength;
    s32 vertexData;
    s32 animData;

    for (i = 0; i < 30; i++) {
        EntityBlueprint* bp = wEntityBlueprint[i];
        if (bp == NULL) {
            break;
        }

        if (!(bp->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL)) {
            s32 temp4;
            dataLength = ((bp->dma.end - bp->dma.start) >> 2);
            temp4 = gEntityHeapBase - totalSize * 4 - dataLength * 4;
            animData = bp->dma.end; // TODO find better match
            totalSize += dma_copy(bp->dma.start, animData, temp4) >> 2;
        } else {
            DmaEntry* dmaList = bp->dmaList;

            if (bp->entityType == ENTITY_TYPE_RESET_MUNCHLESIA) {
                vertexData = gEntityHeapBottom;
                temp1 = dma_copy(dmaList[0].start, dmaList[0].end, vertexData) >> 2;
                dma_copy(dmaList[1].start, dmaList[1].end, gEntityHeapBottom + temp1 * 4) >> 2;
                entity_anim_make_vertex_pointers(bp, gEntityHeapBottom + temp1 * 4, vertexData);
            } else {
                s32 temp5;
                s32 q;

                dataLength = ((dmaList[0].end - dmaList[0].start) >> 2);
                q = gEntityHeapBase - totalSize * 4;
                vertexData = q - dataLength * 4;
                totalSize += dma_copy(dmaList[0].start, dmaList[0].end, vertexData) >> 2;

                dataLength = ((dmaList[1].end - dmaList[1].start) >> 2);
                q = gEntityHeapBase - totalSize * 4;
                animData = q - dataLength * 4;
                totalSize += dma_copy(dmaList[1].start, dmaList[1].end, animData) >> 2;

                entity_anim_make_vertex_pointers(bp, animData, vertexData);
            }
        }
    }
}

void entity_anim_make_vertex_pointers(EntityBlueprint* entityData, void* baseAddr, Vtx* baseVtx) {
    StaticAnimatorNode* node;
    s32* ptr = (s32)baseAddr + (s32)entityData->modelAnimationNodes;

    while (TRUE) {
        if (*ptr == -1) {
            *ptr = 0;
            return;
        }
        node = (s32)baseAddr + ((*ptr) & 0xFFFF);
        *ptr++ = node;

        if (node->displayList != -1) {
            node->displayList = (s32)baseVtx + ((s32)(node->displayList) & 0xFFFF);
        } else {
            node->displayList = NULL;
        }

        if (node->sibling != -1) {
            node->sibling = (s32)baseAddr + ((s32)(node->sibling) & 0xFFFF);
        } else {
            node->sibling = NULL;
        }

        if (node->child != -1) {
            node->child = (s32)baseAddr + ((s32)(node->child) & 0xFFFF);
        } else {
            node->child = NULL;
        }

        if (node->vtxList != -1) {
            node->vtxList = (s32)baseVtx + ((s32)(node->vtxList) & 0xFFFFF);
        } else {
            node->vtxList = NULL;
        }
    }
}

s32 is_entity_data_loaded(Entity* entity, EntityBlueprint* entityData, s32* loadedStart, s32* loadedEnd) {
    EntityBlueprint** blueprints;
    s32 i;
    s32 ret;
    s32 size;
    DmaEntry* entDmaList;

    *loadedStart = 0;
    *loadedEnd = 0;
    ret = FALSE;

    if (!gGameStatusPtr->isBattle) {
        blueprints = wEntityBlueprint;
    } else {
        blueprints = bEntityBlueprint;
    }

    for (i = 0; i < MAX_ENTITIES; i++, blueprints++) {
        EntityBlueprint* bp = *blueprints;
        if (bp == NULL) {
            blueprints[0] = entityData;
            blueprints[1] = NULL;
            ret = TRUE;
            if (entityData->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
                s32 size;
                entDmaList = entityData->dmaList;
                size = (entDmaList[0].end - entDmaList[0].start) >> 2;
                *loadedEnd = *loadedStart + size;
            }
            break;
        } else {
            DmaEntry* bpDmaList = bp->dmaList;
            do {} while (0); // TODO find better match
            entDmaList = entityData->dmaList;
            if (bpDmaList == entDmaList) {
                if (entityData->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
                    s32 size = (bpDmaList[0].end - bpDmaList[0].start) >> 2;
                    *loadedEnd = *loadedStart + size;
                }
                break;
            } else if (bp == entityData) {
                if (bp->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
                    s32 size = (entDmaList[0].end - entDmaList[0].start) >> 2;
                    *loadedEnd = *loadedStart + size;
                }
                break;
            } else {
                if (bp->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
                    s32 size = (bpDmaList[0].end - bpDmaList[0].start) >> 2;
                    *loadedEnd = *loadedStart = *loadedStart + size;
                    size = (bpDmaList[1].end - bpDmaList[1].start) >> 2;;
                    *loadedStart = *loadedStart + size;
                } else {
                    *loadedStart += (bp->dma.end - bp->dma.start) >> 2;
                }
            }
        }
    }

    return ret;
}

void load_simple_entity_data(Entity* entity, EntityBlueprint* entityData, s32 listIndex) {
    s32 loadedStart;
    s32 loadedEnd;
    s32 entitySize;
    u32 temp;
    s32 sizeTemp;

    entity->vertexSegment = 0xA;
    if (!gGameStatusPtr->isBattle) {
        sizeTemp = wEntityBlueprintSize;
    } else {
        sizeTemp = bEntityBlueprintSize;
    }

    if (is_entity_data_loaded(entity, entityData, &loadedStart, &loadedEnd)) {
        if (sizeTemp + ((entityData->dma.end - entityData->dma.start) >> 2) > 0x5FFCU) {
            get_entity_type(entity->listIndex);
            get_entity_type(entity->listIndex);
            PANIC();
        }
        entitySize = (entityData->dma.end - entityData->dma.start) >> 2;
        entity->vertexData = gEntityHeapBase - sizeTemp * 4 - entitySize * 4;
        temp = dma_copy(entityData->dma.start, entityData->dma.end, entity->vertexData);
        sizeTemp += temp / 4;
        get_entity_type(entity->listIndex);
    } else {
        entitySize = (entityData->dma.end - entityData->dma.start) >> 2;
        entity->vertexData = (gEntityHeapBase - (loadedStart * 4)) - (entitySize * 4);
        get_entity_type(entity->listIndex);
    }

    if (!gGameStatusPtr->isBattle) {
        wEntityBlueprintSize = sizeTemp;
    } else {
        bEntityBlueprintSize = sizeTemp;
    }
}

void load_split_entity_data(Entity* entity, EntityBlueprint* entityData, s32 listIndex) {
    s32 s5 = FALSE;
    s32 s2;
    s32 loadedStart, loadedEnd;
    s32 s0;
    s32 v0, v00;
    s32 renderCommandList;
    s32 s22;
    s32 s00;
    s32 specialSize;
    s32 dma1size;
    s32 dma2size_1;
    s32 dma2size_2;
    s32 totalLoaded;
    s32 totalLoadedBytes;

    if (entityData->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
        DmaEntry* dmaList = entityData->dmaList;
        entity->vertexSegment = 0xA;

        switch (entityData->entityType) {
            case ENTITY_TYPE_RESET_MUNCHLESIA:
            case ENTITY_TYPE_MUNCHLESIA_ENVELOP:
            case ENTITY_TYPE_MUNCHLESIA_CHEWING:
            case ENTITY_TYPE_MUNCHLESIA_RESET1:
                specialSize = 0x1000;
                break;
            case ENTITY_TYPE_MUNCHLESIA_GRAB:
            case ENTITY_TYPE_MUNCHLESIA_BEGIN_CHEW:
            case ENTITY_TYPE_MUNCHLESIA_SPIT_OUT:
            case ENTITY_TYPE_MUNCHLESIA_RESET2:
                specialSize = 0x2BC0;
                break;
            default:
                specialSize = 0;
                break;
        }

        if (specialSize != 0) {
            if (entityData->entityType == ENTITY_TYPE_RESET_MUNCHLESIA) {
                is_entity_data_loaded(entity, entityData, &loadedStart, &loadedEnd);
            }
            specialSize -= 0x1000;
            dma1size = dma_copy(dmaList[0].start, dmaList[0].end, gEntityHeapBottom + specialSize * 4) / 4;
            entity->vertexData = gEntityHeapBottom + specialSize * 4;
            dma_copy(dmaList[1].start, dmaList[1].end, gEntityHeapBottom + specialSize * 4 + dma1size * 4);
            s0 = gEntityHeapBottom + specialSize * 4 + dma1size * 4;
            s5 = TRUE;
        } else if (is_entity_data_loaded(entity, entityData, &loadedStart, &loadedEnd)) {
            if (!gGameStatusPtr->isBattle) {
                totalLoaded = wEntityBlueprintSize;
            } else {
                totalLoaded = bEntityBlueprintSize;
            }

            if ((totalLoaded + ((dmaList[0].end - dmaList[0].start) >> 2)) > 0x5FFCU) {
                get_entity_type(entity->listIndex);
                PANIC();
            }

            if ((totalLoaded + ((dmaList[1].end - dmaList[1].start) >> 2)) > 0x5FFCU) {
                get_entity_type(entity->listIndex);
                PANIC();
            }

            dma2size_1 = dma_copy(dmaList[0].start, dmaList[0].end, dmaList[0].start + ((gEntityHeapBase - totalLoaded * 4 - dmaList[0].end) >> 2) * 4) >> 2;
            entity->vertexData = gEntityHeapBase - totalLoaded * 4 - dma2size_1 * 4;
            totalLoaded += dma2size_1;

            dma2size_2 = dma_copy(dmaList[1].start, dmaList[1].end, dmaList[1].start + ((gEntityHeapBase - totalLoaded * 4 - dmaList[1].end) >> 2) * 4) >> 2;
            s0 = gEntityHeapBase - totalLoaded * 4 - dma2size_2 * 4;
            totalLoaded += dma2size_2;
            get_entity_type(entity->listIndex);

            if (!gGameStatusPtr->isBattle) {
                wEntityBlueprintSize = totalLoaded;
            } else {
                bEntityBlueprintSize = totalLoaded;
            }
            s5 = TRUE;
        } else {
            u32 temp = (dmaList[0].end - dmaList[0].start) >> 2;
            entity->vertexData = gEntityHeapBase - loadedStart * 4 - temp * 4;
            temp = (dmaList[1].end - dmaList[1].start) >> 2;
            s0 = gEntityHeapBase - loadedEnd * 4 - temp * 4;
            get_entity_type(entity->listIndex);
        }
    } else {
        entity->virtualModelIndex = create_model_animator(entityData->renderCommandList);
        load_model_animator_tree(entity->virtualModelIndex, entityData->modelAnimationNodes);
        update_model_animator(entity->virtualModelIndex);
        return;
    }
    renderCommandList = entityData->renderCommandList;
    s22 = s0 + (s32)entityData->modelAnimationNodes;
    if (s5) {
        entity_anim_make_vertex_pointers(entityData, s0, entity->vertexData);
    }
    entity->virtualModelIndex = create_mesh_animator(renderCommandList, s0);
    load_mesh_animator_tree(entity->virtualModelIndex, s22);
    update_model_animator(entity->virtualModelIndex);
    entity->flags |= ENTITY_FLAGS_HAS_ANIMATED_MODEL;
}

s32 func_80111790(EntityBlueprint* data) {
    s32 i;

    for (i = 0; i < ARRAY_COUNT(*gCurrentEntityListPtr); i++) {
        Entity* entity = (*gCurrentEntityListPtr)[i];

        if (entity != NULL && entity->blueprint->dma.start != NULL) {
            if (entity->blueprint->dma.start == entity->blueprint) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

void entity_free_static_data(EntityBlueprint* data) {
    s32 i;
    s32 size;
    EntityBlueprint* bp;

    for (i = 0; i < 30; i++) {
        bp = wEntityBlueprint[i];
        if (bp == NULL) {
            break;
        }
    }

    if (i < 30) {
        bp = wEntityBlueprint[i - 1];
        if (bp == data) {
            if (bp->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL) {
                DmaEntry* dmaList = bp->dmaList;
                size = ((dmaList[0].end - dmaList[0].start) >> 2);
                size += ((dmaList[1].end - dmaList[1].start) >> 2);
                if (!func_80111790(bp)) {
                    wEntityBlueprint[i - 1] = NULL;
                    wEntityBlueprintSize -= size;
                }
            } else {
                size = (bp->dma.end - bp->dma.start) >> 2;
                if (!func_80111790(bp)) {
                    wEntityBlueprint[i - 1] = NULL;
                    wEntityBlueprintSize -= size;
                }
            }
        }
    }
}

s32 create_entity(EntityBlueprint* bp, ...) {
    va_list ap;
    EntityBlueprint** bpPtr;
    f32 x;
    f32 y;
    f32 z;
    f32 rotY;
    s32 i;
    s32 listIndex;
    Entity* entity;
    s32* a;

    va_start(ap, bp);
    // needed to match
    bpPtr = &bp;
    *bpPtr = bp;

    load_area_specific_entity_data();

    x = va_arg(ap, s32);
    y = va_arg(ap, s32);
    z = va_arg(ap, s32);
    rotY = va_arg(ap, s32);

    a = &CreateEntityVarArgBuffer[2];

    *a-- = 0;
    *a-- = 0;
    *a = 0;

    for (listIndex = 3; listIndex > 0; listIndex--) {
        s32 arg = va_arg(ap, s32);

        if (arg == MAKE_ENTITY_END) {
            break;
        }
        *a++ = arg;
    }

    va_end(ap);

    for (listIndex = 0; listIndex < ARRAY_COUNT(*gCurrentEntityListPtr); listIndex++) {
        if ((*gCurrentEntityListPtr)[listIndex] == NULL) {
            break;
        }
    }

    if (listIndex >= MAX_ENTITIES) {
        return -1;
    }

    (*gCurrentEntityListPtr)[listIndex] = entity = heap_malloc(sizeof(*entity));
    mem_clear(entity, sizeof(*entity));
    entity->dataBuf.any = NULL;
    if (bp->typeDataSize != 0) {
        entity->dataBuf.any = heap_malloc(bp->typeDataSize);
        mem_clear(entity->dataBuf.any, bp->typeDataSize);
    }
    entity->type = bp->entityType;
    entity->listIndex = listIndex;
    entity->boundScript = NULL;
    entity->updateMatrixOverride = NULL;
    entity->blueprint = bp;
    entity->scriptReadPos = bp->updateEntityScript;
    entity->scriptDelay = entity->scriptReadPos != NULL;
    entity->savedReadPos[0] = bp->updateEntityScript;
    entity->updateScriptCallback = NULL;
    entity->flags = bp->flags | 0x80000000;
    entity->collisionFlags = 0;
    entity->collisionTimer = 0;
    entity->renderSetupFunc = NULL;
    entity->position.x = x;
    entity->position.y = y;
    entity->position.z = z;
    entity->rotation.x = 0.0f;
    entity->rotation.y = rotY;
    entity->rotation.z = 0.0f;
    entity->scale.x = 1.0f;
    entity->scale.y = 1.0f;
    entity->scale.z = 1.0f;
    entity->aabb.x = bp->aabbSize[0];
    entity->aabb.y = bp->aabbSize[1];
    entity->aabb.z = bp->aabbSize[2];
    entity->unk_05 = 1;
    entity->unk_08 = -1;
    entity->alpha = -1;
    entity->virtualModelIndex = -1;
    entity->shadowIndex = -1;
    entity->vertexData = NULL;

    if (!(bp->flags & ENTITY_FLAGS_HAS_ANIMATED_MODEL)) {
        if (bp->dma.start != 0) {
            load_simple_entity_data(entity, bp, listIndex);
        }
        if (bp->renderCommandList != NULL) {
            entity->virtualModelIndex = load_entity_model(bp->renderCommandList);
            exec_entity_model_commandlist(entity->virtualModelIndex);
        }
    } else {
        load_split_entity_data(entity, bp, listIndex);
    }

    if (bp->entityType != ENTITY_TYPE_SHADOW && (entity->flags & (ENTITY_FLAGS_SET_SHADOW_FLAG200 | ENTITY_FLAGS_100))) {
        create_entity_shadow(entity, x, y, z);
    }

    switch (bp->entityType) {
        case ENTITY_TYPE_BLUE_SWITCH:
        case ENTITY_TYPE_RED_SWITCH:
        case ENTITY_TYPE_SIMPLE_SPRING:
        case ENTITY_TYPE_SCRIPT_SPRING:
        case ENTITY_TYPE_STAR_BOX_LAUCHER:
            entity->flags |= ENTITY_FLAGS_4000;
            break;
    }

    if (bp->fpInit != NULL) {
        bp->fpInit(entity);
    }

    update_entity_transform_matrix(entity);
    return entity->listIndex;
}

s32 create_shadow_from_data(ShadowBlueprint* data, f32 x, f32 y, f32 z) {
    Shadow* shadow;
    s32 i;

    for (i = 0; i < ARRAY_COUNT(*gCurrentShadowListPtr); i++) {
        if ((*gCurrentShadowListPtr)[i] == NULL) {
            break;
        }
    }

    ASSERT(i < ARRAY_COUNT(*gCurrentShadowListPtr));

    shadow = heap_malloc(sizeof(*shadow));
    (*gCurrentShadowListPtr)[i] = shadow;
    mem_clear(shadow, sizeof(*shadow));
    shadow->listIndex = i;
    shadow->flags = data->flags | SHADOW_FLAGS_80000000;
    shadow->alpha = 0x80;
    shadow->unk_06 = 0x80;
    shadow->position.x = x;
    shadow->position.y = y;
    shadow->position.z = z;
    shadow->scale.x = 1.0f;
    shadow->scale.y = 1.0f;
    shadow->scale.z = 1.0f;

    if (data->animModelNode != NULL) {
        shadow->flags |= SHADOW_FLAGS_COMPLEX_MODEL;
        shadow->entityModelID = create_model_animator(data->renderCommandList);
        load_model_animator_tree(shadow->entityModelID, data->animModelNode);
    } else {
        shadow->entityModelID = load_entity_model(data->renderCommandList);
    }

    if (data->onCreateCallback != NULL) {
        data->onCreateCallback(shadow);
    }
    update_shadow_transform_matrix(shadow);
    return shadow->listIndex;
}

s32 MakeEntity(Evt* script, s32 isInitialCall) {
    Bytecode* args = script->ptrReadPos;
    EntityBlueprint* entityData;
    s32 x, y, z;
    s32 flags;
    s32 nextArg;
    s32 entityIndex;
    s32 endOfArgs;
    s32* varArgBufPos;

    if (isInitialCall != TRUE) {
        return ApiStatus_DONE2;
    }

    entityData = (EntityBlueprint*)evt_get_variable(script, *args++);
    varArgBufPos = &CreateEntityVarArgBuffer[2];
    endOfArgs = MAKE_ENTITY_END;
    x = evt_get_variable(script, *args++);
    y = evt_get_variable(script, *args++);
    z = evt_get_variable(script, *args++);
    flags = evt_get_variable(script, *args++);

    *varArgBufPos-- = 0;
    *varArgBufPos-- = 0;
    *varArgBufPos = 0;

    do {
        nextArg = evt_get_variable(script, *args++);

        if (nextArg != endOfArgs) {
            *varArgBufPos++ = nextArg;
        }
    } while (nextArg != endOfArgs);

    entityIndex = create_entity(entityData, x, y, z, flags, CreateEntityVarArgBuffer[0], CreateEntityVarArgBuffer[1], CreateEntityVarArgBuffer[2], endOfArgs);
    gLastCreatedEntityIndex = entityIndex;
    script->varTable[0] = entityIndex;
    return ApiStatus_DONE2;
}

ApiStatus SetEntityCullMode(Evt* script, s32 isInitialCall) {
    Entity* entity = get_entity_by_index(gLastCreatedEntityIndex);
    Bytecode* args = script->ptrReadPos;
    s32 mode = evt_get_variable(script, *args++);

    if (mode == 0) {
        entity->flags |= ENTITY_FLAGS_DRAW_IF_CLOSE_HIDE_MODE1;
    } else if (mode == 1) {
        entity->flags |= ENTITY_FLAGS_DRAW_IF_CLOSE_HIDE_MODE2;
    } else if (mode == 2) {
        entity->flags |= ENTITY_FLAGS_DRAW_IF_CLOSE_HIDE_MODE2 | ENTITY_FLAGS_DRAW_IF_CLOSE_HIDE_MODE1;
    } else {
        entity->flags |= ENTITY_FLAGS_IGNORE_DISTANCE_CULLING | ENTITY_FLAGS_DRAW_IF_CLOSE_HIDE_MODE2 |
                         ENTITY_FLAGS_DRAW_IF_CLOSE_HIDE_MODE1;
    }
    return ApiStatus_DONE2;
}

ApiStatus UseDynamicShadow(Evt* script, s32 isInitialCall) {
    Entity* entity = get_entity_by_index(gLastCreatedEntityIndex);
    Bytecode* args = script->ptrReadPos;

    if (evt_get_variable(script, *args++)) {
        Shadow* shadow;

        entity->flags |= ENTITY_FLAGS_HAS_DYNAMIC_SHADOW;
        shadow = get_shadow_by_index(entity->shadowIndex);
        shadow->flags |= SHADOW_FLAGS_POSITION_DIRTY;
    } else {
        entity->flags &= ~ENTITY_FLAGS_HAS_DYNAMIC_SHADOW;
    }

    return ApiStatus_DONE2;
}

ApiStatus AssignScript(Evt* script, s32 isInitialCall) {
    Bytecode* args = script->ptrReadPos;

    if (isInitialCall == TRUE) {
        EvtScript* toBind = (EvtScript*)evt_get_variable(script, *args++);

        get_entity_by_index(gLastCreatedEntityIndex)->boundScriptBytecode = toBind;
        return ApiStatus_DONE2;
    }

    return ApiStatus_DONE1;
}

ApiStatus AssignAreaFlag(Evt* script, s32 isInitialCall) {
    Bytecode* args = script->ptrReadPos;

    if (isInitialCall == TRUE) {
        s32 temp_s0 = evt_get_variable(script, *args++);
        Entity* entity = get_entity_by_index(gLastCreatedEntityIndex);

        // TODO find proper struct for the dataBuf
        ((s16*)(entity->dataBuf.unk))[16] = temp_s0;
        if (get_area_flag(temp_s0) != 0) {
            entity->flags |= ENTITY_FLAGS_PENDING_INSTANCE_DELETE;
        }
        return ApiStatus_DONE2;
    }

    return ApiStatus_DONE1;
}

ApiStatus AssignBlockFlag(Evt* script, s32 isInitialCall) {
    Bytecode* args = script->ptrReadPos;

    if (isInitialCall == TRUE) {
        s32 index = evt_get_variable_index(script, *args++);

        BlockData* data = get_entity_by_index(gLastCreatedEntityIndex)->dataBuf.block;
        data->gameFlagIndex = index;

        return ApiStatus_DONE2;
    }

    return ApiStatus_DONE1;
}

ApiStatus AssignChestFlag(Evt* script, s32 isInitialCall) {
    Bytecode* args = script->ptrReadPos;

    if (isInitialCall == TRUE) {
        ChestData* data = get_entity_by_index(gLastCreatedEntityIndex)->dataBuf.chest;
        data->gameFlagIndex = evt_get_variable_index(script, *args);

        return ApiStatus_DONE2;
    }

    return ApiStatus_DONE1;
}

ApiStatus AssignPanelFlag(Evt* script, s32 isInitialCall) {
    Bytecode* args = script->ptrReadPos;

    if (isInitialCall == TRUE) {
        // TODO find proper struct for the dataBuf
        s16* dataBuf = (s16*)get_entity_by_index(gLastCreatedEntityIndex)->dataBuf.unk;

        dataBuf[3] = evt_get_variable_index(script, *args++);
        return ApiStatus_DONE2;
    }

    return ApiStatus_DONE1;
}

ApiStatus AssignCrateFlag(Evt* script, s32 isInitialCall) {
    Bytecode* args = script->ptrReadPos;

    if (isInitialCall == TRUE) {
        // TODO find proper struct for the dataBuf
        s16* dataBuf = (s16*)get_entity_by_index(gLastCreatedEntityIndex)->dataBuf.unk;

        dataBuf[2] = evt_get_variable_index(script, *args++);
        return ApiStatus_DONE2;
    }

    return ApiStatus_DONE1;
}

s32 create_entity_shadow(Entity* entity, f32 x, f32 y, f32 z) {
    u16 staticFlags = entity->blueprint->flags;
    s32 type;
    s16 shadowIndex;

    if (staticFlags & 0x200) {
        if (staticFlags & 0x800) {
            type = 2;
        } else {
            type = 3;
        }
    } else {
        type = ((staticFlags >> 11) ^ 1) & 1;
    }

    shadowIndex = create_shadow_type(type, x, y, z);
    entity->shadowIndex = shadowIndex;

    get_shadow_by_index(shadowIndex)->flags |= 0xC00000;

    return entity->shadowIndex;
}

s32 create_shadow_type(s32 type, f32 x, f32 y, f32 z) {
    s32 setFlag200 = FALSE;
    ShadowBlueprint* data = &CircularShadowA;
    s32 shadowIndex;

    switch (type) {
        case 2:
            setFlag200 = TRUE;
        case 0:
            data = &CircularShadowA;
            break;
        case 3:
            setFlag200 = TRUE;
        case 1:
            data = &SquareShadow;
            break;
        case 5:
            setFlag200 = TRUE;
        case 4:
            data = &CircularShadowB;
            break;
    }

    shadowIndex = create_shadow_from_data(data, x, y, z);

    if (setFlag200) {
        get_shadow_by_index(shadowIndex)->flags |= 0x200;
    }

    return shadowIndex;
}

void delete_shadow(s32 shadowIndex) {
    _delete_shadow(shadowIndex);
}

void update_entity_shadow_position(Entity* entity) {
    Shadow* shadow = get_shadow_by_index(entity->shadowIndex);

    if (shadow != NULL) {
        f32 rayX;
        f32 rayY;
        f32 rayZ;
        f32 hitYaw;
        f32 hitPitch;
        f32 hitLength;
        f32 origHitLength;

        if (entity->alpha < 255) {
            shadow->alpha = entity->alpha / 2;
        } else {
            u8 alphaTemp;

            if (shadow->flags & SHADOW_FLAGS_800000) {
                alphaTemp = 160;
            } else {
                alphaTemp = 128;
            }
            shadow->alpha = alphaTemp;
        }

        if (!(entity->flags & ENTITY_FLAGS_HAS_DYNAMIC_SHADOW)) {
            if (shadow->flags & SHADOW_FLAGS_POSITION_DIRTY) {
                shadow->flags &= ~SHADOW_FLAGS_POSITION_DIRTY;
            } else {
                return;
            }
        }

        rayX = entity->position.x;
        rayY = entity->position.y;
        rayZ = entity->position.z;

        if (!entity_raycast_down(&rayX, &rayY, &rayZ, &hitYaw, &hitPitch, &hitLength) && hitLength == 32767.0f) {
            hitLength = 0.0f;
        }

        origHitLength = hitLength;

        if (shadow->flags & SHADOW_FLAGS_200) {
            hitLength = 212.5f;
            shadow->scale.x = entity->aabb.x / hitLength;
            shadow->scale.z = entity->aabb.z / hitLength;
        } else {
            hitLength = ((hitLength / 150.0f) + 0.95) * 250.0;
            shadow->scale.x = (entity->aabb.x / hitLength) * entity->scale.x;
            shadow->scale.z = (entity->aabb.z / hitLength) * entity->scale.z;
        }

        shadow->position.x = entity->position.x;
        shadow->position.z = entity->position.z;
        shadow->position.y = rayY;
        entity->shadowPosY = rayY;
        shadow->rotation.x = hitYaw;
        shadow->rotation.z = hitPitch;
        shadow->rotation.y = entity->rotation.y;

        if (entity->position.y < rayY) {
            shadow->flags |= SHADOW_FLAGS_40000000;
            entity->position.y = rayY + 10.0f;
        } else {
            shadow->flags &= ~SHADOW_FLAGS_40000000;
        }

        shadow->flags = (shadow->flags & ~SHADOW_FLAGS_HIDDEN) | ((u16)entity->flags & ENTITY_FLAGS_HIDDEN);
        if (!(entity->flags & ENTITY_FLAGS_400) && origHitLength == 0.0f) {
            shadow->flags |= SHADOW_FLAGS_HIDDEN;
        }
    } else {
        entity->shadowPosY = 0.0f;
    }
}

s32 entity_raycast_down(f32* x, f32* y, f32* z, f32* hitYaw, f32* hitPitch, f32* hitLength) {
    f32 hitX, hitY, hitZ;
    f32 hitDepth;
    f32 hitNx, hitNy, hitNz;
    s32 entityID;
    s32 colliderID;
    s32 hitID;
    s32 ret;

    hitDepth = 32767.0f;
    *hitLength = 32767.0f;
    entityID = test_ray_entities(*x, *y, *z, 0.0f, -1.0f, 0.0f, &hitX, &hitY, &hitZ, &hitDepth, &hitNx, &hitNy, &hitNz);
    hitID = -1;
    ret = FALSE;

    if ((entityID >= 0) && ((get_entity_type(entityID) != 0xC) || (hitNx == 0.0f && hitNz == 0.0f && hitNy == 1.0))) {
        hitID = entityID | COLLISION_WITH_ENTITY_BIT;
    }

    colliderID = test_ray_colliders(0x10000, *x, *y, *z, 0.0f, -1.0f, 0.0f, &hitX, &hitY, &hitZ, &hitDepth, &hitNx,
                                    &hitNy, &hitNz);
    if (colliderID >= 0) {
        hitID = colliderID;
    }

    if (hitID >= 0) {
        *hitLength = hitDepth;
        *y = hitY;
        *hitYaw = -atan2(0.0f, 0.0f, hitNz * 100.0f, hitNy * 100.0f);
        *hitPitch = -atan2(0.0f, 0.0f, hitNx * 100.0f, hitNy * 100.0f);
        ret = TRUE;
    } else {
        *hitYaw = 0.0f;
        *hitPitch = 0.0f;
    }
    return ret;
}

void set_standard_shadow_scale(Shadow* shadow, f32 height) {
    if (!gGameStatusPtr->isBattle) {
        shadow->scale.x = 0.13 - (height / 2600.0f);
    } else {
        shadow->scale.x = 0.12 - (height / 3600.0f);
    }

    if (shadow->scale.x < 0.01) {
        shadow->scale.x = 0.01f;
    }
    shadow->scale.z = shadow->scale.x;
}

void set_npc_shadow_scale(Shadow* shadow, f32 height, f32 npcRadius) {
    if (!gGameStatusPtr->isBattle) {
        shadow->scale.x = 0.13 - (height / 2600.0f);
    } else {
        shadow->scale.x = 0.12 - (height / 3600.0f);
    }

    if (shadow->scale.x < 0.01) {
        shadow->scale.x = 0.01f;
    }

    if (npcRadius > 60.0f) {
        shadow->scale.z = shadow->scale.x * 2.0f;
    } else {
        shadow->scale.z = shadow->scale.x;
    }
}

void set_peach_shadow_scale(Shadow* shadow, f32 scale) {
    PlayerStatus* playerStatus = &gPlayerStatus;
    f32 phi_f2 = 0.12f;

    if (!gGameStatusPtr->isBattle) {
        switch (playerStatus->anim) {
            case 0xC0018:
            case 0xC0019:
            case 0xC001A:
            case 0xD0008:
                shadow->scale.x = 0.26f - (scale / 2600.0f);
                if (shadow->scale.x < 0.01) {
                    shadow->scale.x = 0.01f;
                }
                shadow->scale.z = 0.13f - (scale / 2600.0f);
                if (shadow->scale.z < 0.01) {
                    shadow->scale.z = 0.01f;
                }
                return;
        }

        phi_f2 = 0.16f;
    }

    shadow->scale.x = phi_f2 - (scale / 3600.0f);
    if (shadow->scale.x < 0.01) {
        shadow->scale.x = 0.01f;
    }
    shadow->scale.z = shadow->scale.x;
}

s32 is_block_on_ground(Entity* block) {
    f32 x = block->position.x;
    f32 y = block->position.y;
    f32 z = block->position.z;
    f32 hitYaw;
    f32 hitPitch;
    f32 hitLength;
    s32 ret;

    entity_raycast_down(&x, &y, &z, &hitYaw, &hitPitch, &hitLength);

    ret = hitLength;
    if (ret == 32767) {
        ret = FALSE;
    }

    return ret;
}

void state_delegate_NOP(void) {
}

void clear_game_modes(void) {
    GameMode* gameMode;
    s32 i;

    for (gameMode = gMainGameState, i = 0; i < ARRAY_COUNT(gMainGameState); i++, gameMode++) {
        gameMode->flags = 0;
    }
}

GameMode* set_next_game_mode(GameMode* arg0) {
    GameMode* gameMode;
    s32 i;

    for (gameMode = gMainGameState, i = 0; i < ARRAY_COUNT(gMainGameState); i++, gameMode++) {
        if (gameMode->flags == 0) {
            break;
        }
    }

    ASSERT(i < ARRAY_COUNT(gMainGameState));

    gameMode->flags = 1 | 2;
    gameMode->init = arg0->init;
    gameMode->step = arg0->step;
    gameMode->render = arg0->render;
    gameMode->unk_0C = NULL;

    if (gameMode->init == NULL) {
        gameMode->init = state_delegate_NOP;
    }
    if (gameMode->step == NULL) {
        gameMode->step = state_delegate_NOP;
    }
    if (gameMode->unk_0C == NULL) {
        gameMode->unk_0C = state_delegate_NOP;
    }
    if (gameMode->render == NULL) {
        gameMode->render = state_delegate_NOP;
    }

    gameMode->renderAux = state_delegate_NOP;
    gameMode->init();

    return gameMode;
}

GameMode* set_game_mode_slot(s32 i, GameMode* arg0) {
    GameMode* gameMode = &gMainGameState[i];

    ASSERT(i < ARRAY_COUNT(gMainGameState));

    gameMode->flags = 1 | 2;
    gameMode->init = arg0->init;
    gameMode->step = arg0->step;
    gameMode->render = arg0->render;
    gameMode->unk_0C = NULL;
    if (gameMode->init == NULL) gameMode->init = state_delegate_NOP;
    if (gameMode->step == NULL) gameMode->step = state_delegate_NOP;
    if (gameMode->unk_0C == NULL) gameMode->unk_0C = state_delegate_NOP;
    if (gameMode->render == NULL) gameMode->render = state_delegate_NOP;

    gameMode->renderAux = state_delegate_NOP;
    gameMode->init();

    return gameMode;
}

void game_mode_set_fpDrawAuxUI(s32 i, void (*fn)(void)) {
    GameMode* gameMode = &gMainGameState[i];

    ASSERT(i < ARRAY_COUNT(gMainGameState));

    gameMode->renderAux = fn;
    gameMode->flags |= 0x20;

    if (fn == NULL) {
        gameMode->renderAux = state_delegate_NOP;
    }
}

void func_80112DD4(s32 i) {
    gMainGameState[i].flags |= 4;
}

void func_80112DFC(s32 i) {
    gMainGameState[i].flags |= 8;
}

void func_80112E24(s32 i) {
    gMainGameState[i].flags &= ~0x1C;
}

void func_80112E4C(s32 i) {
    gMainGameState[i].flags &= ~0x0C;
    gMainGameState[i].flags |= 0x10;
}

void step_current_game_mode(void) {
    GameMode* gameMode = gMainGameState;
    s32 i;

    for (i = 0; i < ARRAY_COUNT(gMainGameState); i++, gameMode++) {
        if (gameMode->flags != 0) {
            if (!(gameMode->flags & 4)) {
                if (!(gameMode->flags & 8)) {
                    gameMode->flags &= ~2;
                    gameMode->step();
                }
            }
        }
    }
}

void state_do_unk(void) {
    GameMode* gameMode = gMainGameState;
    s32 i;

    for (i = 0; i < ARRAY_COUNT(gMainGameState); i++, gameMode++) {
        if (gameMode->flags != 0) {
            if (!(gameMode->flags & 4)) {
                if (!(gameMode->flags & 0x10)) {
                    gameMode->unk_0C();
                }
            }
        }
    }
}

void state_render_backUI(void) {
    GameMode* gameMode = gMainGameState;
    s32 i;

    for (i = 0; i < ARRAY_COUNT(gMainGameState); i++, gameMode++) {
        if (gameMode->flags != 0) {
            if (!(gameMode->flags & 4)) {
                if (!(gameMode->flags & 0x10)) {
                    gameMode->render();
                }
            }
        }
    }
}

void state_render_frontUI(void) {
    GameMode* gameMode = gMainGameState;
    s32 i;

    for (i = 0; i < ARRAY_COUNT(gMainGameState); i++, gameMode++) {
        if (gameMode->flags != 0) {
            if (!(gameMode->flags & 4)) {
                if (!(gameMode->flags & 2)) {
                    if (gameMode->flags & 0x20) {
                        gameMode->renderAux();
                    }
                }
            }
        }
    }

    // re-initialization needed - evidence of inlining? or just copy/pasting?
    gameMode = &gMainGameState[0];
    for (i = 0; i < ARRAY_COUNT(gMainGameState); i++, gameMode++) {
        if (gameMode->flags != 0) {
            if (!(gameMode->flags & 4)) {
                if (!(gameMode->flags & 2)) {
                    if (gameMode->flags & 0x10) {
                        gameMode->render();
                    }
                }
            }
        }
    }
}

void appendGfx_model(Model* model);
INCLUDE_ASM(void, "a5dd0_len_114e0", appendGfx_model, Model*);

INCLUDE_ASM(s32, "a5dd0_len_114e0", func_80114B58);

void load_tile_header(char* textureName, s32 romOffset, s32 size);
INCLUDE_ASM(s32, "a5dd0_len_114e0", load_tile_header);

INCLUDE_ASM(s32, "a5dd0_len_114e0", func_80115498);

// Goofy temps needed to match
ModelNodeProperty* get_model_property(ModelNode* node, ModelPropertyKeys key) {
    s32 numProperties = node->numProperties;
    ModelNodeProperty* propertyList = node->propertyList;
    s32 i;

    for (i = 0; i < numProperties; i++, propertyList++) {
        if (propertyList->key == key) {
            return propertyList;
        }
    }
    return NULL;
}

void _load_model_textures(ModelNode* model, s32 romOffset, s32 size) {
    if (model->type != 2) {
        if (model->groupData != NULL) {
            s32 numChildren = model->groupData->numChildren;

            if (numChildren != 0) {
                s32 i;

                for (i = 0; i < numChildren; i++) {
                    _load_model_textures(model->groupData->childList[i], romOffset, size);
                }
            }
        }
    } else {
        char* textureName = (char*)get_model_property(model, MODEL_PROP_KEY_TEXTURE_NAME);
        if (textureName != NULL) {
            load_tile_header(textureName, romOffset, size);
        }
    }
    mdl_treeIterPos++;
}

void load_model_textures(ModelNode* model, s32 romOffset, s32 size) {
    s32 battleOffset = ((gGameStatusPtr->isBattle != 0) << 17);

    mdl_nextTextureAddress = mdl_textureBaseAddress + battleOffset;

    if (model != NULL && romOffset != 0 && size != 0) {
        s32 i;

        for (i = 0; i < ARRAY_COUNT(mdl_textureHandles); i++) {
            mdl_textureHandles[i].gfx = NULL;
        }

        mdl_treeIterPos = 0;
        if (model != NULL) {
            _load_model_textures(model, romOffset, size);
        }
    }
}

s32 mdl_get_child_count(ModelNode* model) {
    s32 ret = 0;

    if (model->type != 2 && model->groupData != NULL) {
        s32 numChildren = model->groupData->numChildren;

        if (numChildren != 0) {
            s32 i;

            ret += numChildren;
            for (i = 0; i < numChildren; i++) {
                ret += mdl_get_child_count(model->groupData->childList[i]);
            }
        }
    }
    return ret;
}

void clear_model_data(void) {
    s32 i;

    if (!gGameStatusPtr->isBattle) {
        gCurrentModels = &wModelList;
        gCurrentTransformGroups = &wTransformGroups;
        gCurrentCustomModelGfxPtr = &wModelSpecialDls;
        gCurrentCustomModelGfxBuildersPtr = &wCustomModelGfxBuilders;
        gCurrentModelTreeRoot = &D_80152214;
        gCurrentModelLocalVtxBuffers = &wModelLocalVtxBuffers;
        mdl_currentModelTreeNodeInfo = &D_80152220;
        D_801512F0 = &wBgRenderType;
        mdl_bgMultiplyColorA = 0;
        mdl_bgMultiplyColorR = 0;
        mdl_bgMultiplyColorG = 0;
        mdl_bgMultiplyColorB = 0;
        gCurrentFogSettings = &wFogSettings;
    } else {
        gCurrentModels = &bModelList;
        gCurrentTransformGroups = &bTransformGroups;
        gCurrentCustomModelGfxPtr = &bModelSpecialDls;
        gCurrentCustomModelGfxBuildersPtr = &bCustomModelGfxBuilders;
        gCurrentModelTreeRoot = &D_80152218;
        gCurrentModelLocalVtxBuffers = &bModelLocalVtxBuffers;
        mdl_currentModelTreeNodeInfo = &D_80152A20;
        D_801512F0 = &bBgRenderType;
        gCurrentFogSettings = &bFogSettings;
    }

    for (i = 0; i < ARRAY_COUNT(*gCurrentModels); i++) {
        (*gCurrentModels)[i] = 0;
    }

    for (i = 0; i < ARRAY_COUNT(*gCurrentTransformGroups); i++) {
        (*gCurrentTransformGroups)[i] = 0;
    }

    for (i = 0; i < ARRAY_COUNT(*gCurrentCustomModelGfxPtr); i++) {
        (*gCurrentCustomModelGfxPtr)[i] = 0;
        (*gCurrentCustomModelGfxBuildersPtr)[i] = 0;
    }

    *gCurrentModelTreeRoot = NULL;

    for (i = 0; i < ARRAY_COUNT(*mdl_currentModelTreeNodeInfo); i++) {
        (*mdl_currentModelTreeNodeInfo)[i].modelIndex = -1;
        (*mdl_currentModelTreeNodeInfo)[i].treeDepth = 0;
        (*mdl_currentModelTreeNodeInfo)[i].textureID = 0;
    }

    *D_801512F0 = 0;
    gCurrentFogSettings->r = 10;
    gCurrentFogSettings->g = 10;
    gCurrentFogSettings->b = 10;
    gCurrentFogSettings->startDistance = 950;
    gCurrentFogSettings->enabled = FALSE;
    gCurrentFogSettings->a = 0;
    gCurrentFogSettings->endDistance = 1000;

    for (i = 0; i < ARRAY_COUNT(texPannerAuxV); i++) {
        texPannerAuxV[i] = 0;
        texPannerAuxU[i] = 0;
        texPannerMainV[i] = 0;
        texPannerMainU[i] = 0;
    }
}

void init_model_data(void) {
    if (!gGameStatusPtr->isBattle) {
        gCurrentModels = &wModelList;
        gCurrentTransformGroups = &wTransformGroups;
        gCurrentCustomModelGfxPtr = &wModelSpecialDls;
        gCurrentCustomModelGfxBuildersPtr = &wCustomModelGfxBuilders;
        gCurrentModelTreeRoot = &D_80152214;
        gCurrentModelLocalVtxBuffers = &wModelLocalVtxBuffers;
        mdl_currentModelTreeNodeInfo = &D_80152220;
        D_801512F0 = &wBgRenderType;
        gCurrentFogSettings = &wFogSettings;
    } else {
        gCurrentModels = &bModelList;
        gCurrentTransformGroups = &bTransformGroups;
        gCurrentCustomModelGfxPtr = &bModelSpecialDls;
        gCurrentCustomModelGfxBuildersPtr = &bCustomModelGfxBuilders;
        gCurrentModelTreeRoot = &D_80152218;
        gCurrentModelLocalVtxBuffers = &bModelLocalVtxBuffers;
        mdl_currentModelTreeNodeInfo = &D_80152A20;
        D_801512F0 = &bBgRenderType;
        gCurrentFogSettings = &bFogSettings;
    }
}

void calculate_model_sizes(void) {
    s32 i;

    for (i = 0; i < ARRAY_COUNT(*gCurrentModels); i++) {
        Model* model = (*gCurrentModels)[i];

        if (model != NULL) {
            ModelBoundingBox* bb = (ModelBoundingBox*)get_model_property(model->modelNode, MODEL_PROP_KEY_BOUNDING_BOX);

            bb->halfSizeX = (bb->maxX - bb->minX) * 0.5;
            bb->halfSizeY = (bb->maxY - bb->minY) * 0.5;
            bb->halfSizeZ = (bb->maxZ - bb->minZ) * 0.5;
            model->flags |= MODEL_FLAGS_USES_TRANSFORM_MATRIX;
        }
    }
}

void mdl_create_model(ModelBlueprint* bp, s32 arg1);
INCLUDE_ASM(s32, "a5dd0_len_114e0", mdl_create_model);

// The global here is getting optimized out because nothing is happening to it. Very weird
#ifdef NON_EQUIVALENT
void func_80116674(void) {
    s32 i;

    for (i = 0; i < ARRAY_COUNT(*gCurrentModels); i++) {
        Model* m = (*gCurrentModels)[i];
        do {} while (0);
    }
}
#else
INCLUDE_ASM(s32, "a5dd0_len_114e0", func_80116674);
#endif

INCLUDE_ASM(s32, "a5dd0_len_114e0", func_80116698);

// this function has weird control flow and suqqz
#ifdef NON_EQUIVALENT
void render_models(void) {
    Camera* camera = &gCameras[gCurrentCameraID];
    s32 distance;
    s32 cond;
    s32 i;

    RenderTask rt;
    RenderTask* rtPtr = &rt;
    f32 sp38;
    f32 sp3C;
    f32 sp40;
    f32 sp44;
    f32 sp48;
    f32 sp4C;
    f32 sp50;
    f32 sp54;
    f32 sp58;
    f32 sp5C;
    f32 sp60;
    f32 sp64;
    f32 sp68;
    f32 sp6C;
    f32 sp70;
    f32 sp74;
    f32 sp78;
    f32 sp7C;
    f32 sp80;
    f32 sp84;
    f32 centerX, centerY, centerZ;
    f32 sp98;
    f32 spA0;

    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    f32 temp_f0_7;
    f32 temp_f0_8;
    f32 temp_f12;
    f32 temp_f12_10;
    f32 temp_f12_11;
    f32 temp_f12_12;
    f32 temp_f12_13;
    f32 temp_f12_14;
    f32 temp_f12_15;
    f32 temp_f12_16;
    f32 temp_f12_2;
    f32 temp_f12_3;
    f32 temp_f12_4;
    f32 temp_f12_5;
    f32 temp_f12_6;
    f32 temp_f12_7;
    f32 temp_f12_8;
    f32 temp_f12_9;
    f32 temp_f20;
    f32 temp_f20_2;
    f32 temp_f20_3;
    f32 temp_f20_4;
    f32 temp_f20_5;
    f32 temp_f20_6;
    f32 temp_f20_7;
    f32 temp_f20_8;
    f32 temp_f26;
    f32 temp_f28;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    f32 temp_f2_4;
    f32 temp_f2_5;
    f32 temp_f2_6;
    f32 temp_f2_7;
    f32 temp_f2_8;
    f32 temp_f4;
    f32 temp_f4_10;
    f32 temp_f4_11;
    f32 temp_f4_12;
    f32 temp_f4_13;
    f32 temp_f4_14;
    f32 temp_f4_15;
    f32 temp_f4_16;
    f32 temp_f4_17;
    f32 temp_f4_18;
    f32 temp_f4_19;
    f32 temp_f4_20;
    f32 temp_f4_21;
    f32 temp_f4_22;
    f32 temp_f4_23;
    f32 temp_f4_24;
    f32 temp_f4_2;
    f32 temp_f4_3;
    f32 temp_f4_4;
    f32 temp_f4_5;
    f32 temp_f4_6;
    f32 temp_f4_7;
    f32 temp_f4_8;
    f32 temp_f4_9;
    f32 temp_f6;
    f32 temp_f6_2;
    f32 temp_f6_3;
    f32 temp_f6_4;
    f32 temp_f6_5;
    f32 temp_f6_6;
    f32 temp_f6_7;
    f32 temp_f6_8;
    f32 temp_f8;
    f32 temp_f8_2;
    f32 temp_f8_3;
    f32 temp_f8_4;
    f32 temp_f8_5;
    f32 temp_f8_6;
    f32 temp_f8_7;
    f32 temp_f8_8;

    sp48 = camera->perspectiveMatrix[0][0];
    sp4C = camera->perspectiveMatrix[0][1];
    sp50 = camera->perspectiveMatrix[0][2];
    sp54 = camera->perspectiveMatrix[0][3];
    sp58 = camera->perspectiveMatrix[1][0];
    sp5C = camera->perspectiveMatrix[1][1];
    sp60 = camera->perspectiveMatrix[1][2];
    sp64 = camera->perspectiveMatrix[1][3];
    sp68 = camera->perspectiveMatrix[2][0];
    sp6C = camera->perspectiveMatrix[2][1];
    sp70 = camera->perspectiveMatrix[2][2];
    sp74 = camera->perspectiveMatrix[2][3];
    sp78 = camera->perspectiveMatrix[3][0];
    sp7C = camera->perspectiveMatrix[3][1];
    sp80 = camera->perspectiveMatrix[3][2];
    sp84 = camera->perspectiveMatrix[3][3];

    for (i = 0; i < ARRAY_COUNT(*gCurrentModels); i++) {
        Model* model = (*gCurrentModels)[i];

        if (model != NULL) {
            if (model->flags == 0) {
                continue;
            }

            if (model->flags & 4) {
                continue;
            }

            if (model->flags & 2) {
                continue;
            }

            if (model->flags & 0x20) {
                continue;
            }

            if (model->flags & 0x8) {
                continue;
            }

            centerX = model->center.x;
            centerY = model->center.y;
            centerZ = model->center.z;

            if (model->flags & 0x200) {
                ModelNodeProperty* propertyList = model->modelNode->propertyList;

                temp_f26 = (f32) propertyList->dataType;
                sp98 = temp_f26;
                spA0 = (f32) propertyList[1].dataType;
                temp_f28 = (f32) propertyList[1].key;
                temp_f4 = centerX - temp_f26;
                temp_f12 = centerY - spA0;
                temp_f20 = centerZ - temp_f28;
                temp_f6 = (sp48 * temp_f4) + (sp58 * temp_f12) + (sp68 * temp_f20) + sp78;
                temp_f8 = (sp4C * temp_f4) + (sp5C * temp_f12) + (sp6C * temp_f20) + sp7C;
                temp_f2 = (sp50 * temp_f4) + (sp60 * temp_f12) + (sp70 * temp_f20) + sp80;
                temp_f4_2 = (sp54 * temp_f4) + (sp64 * temp_f12) + (sp74 * temp_f20) + sp84;
                cond = FALSE;

                if ((temp_f4_2 != 0.0f) &&
                ((temp_f0 = 1.0f / temp_f4_2, temp_f4_3 = temp_f6 * temp_f0, temp_f12_2 = temp_f8 * temp_f0, !((temp_f2 * temp_f0) > -1.0f)) || !(temp_f4_3 >= -1.0f) || !(temp_f4_3 <= 1.0f) || !(temp_f12_2 >= -1.0f) || !(temp_f12_2 <= 1.0f)) && ((sp98 == 0.0f) || ((temp_f4_4 = centerX + sp98, temp_f12_3 = centerY - spA0, temp_f20_2 = centerZ - temp_f28, temp_f6_2 = (sp48 * temp_f4_4) + (sp58 * temp_f12_3) + (sp68 * temp_f20_2) + sp78, temp_f8_2 = (sp4C * temp_f4_4) + (sp5C * temp_f12_3) + (sp6C * temp_f20_2) + sp7C, temp_f2_2 = (sp50 * temp_f4_4) + (sp60 * temp_f12_3) + (sp70 * temp_f20_2) + sp80, temp_f4_5 = (sp54 * temp_f4_4) + (sp64 * temp_f12_3) + (sp74 * temp_f20_2) + sp84, (temp_f4_5 != 0.0f)) && ((temp_f0_2 = 1.0f / temp_f4_5, temp_f4_6 = temp_f6_2 * temp_f0_2, temp_f12_4 = temp_f8_2 * temp_f0_2, !((temp_f2_2 * temp_f0_2) > -1.0f)) || !(temp_f4_6 >= -1.0f) || !(temp_f4_6 <= 1.0f) || !(temp_f12_4 >= -1.0f) || !(temp_f12_4 <= 1.0f)))) && ((spA0 == 0.0f) || ((temp_f4_7 = centerX - sp98, temp_f12_5 = centerY + spA0, temp_f20_3 = centerZ - temp_f28, temp_f6_3 = (sp48 * temp_f4_7) + (sp58 * temp_f12_5) + (sp68 * temp_f20_3) + sp78, temp_f8_3 = (sp4C * temp_f4_7) + (sp5C * temp_f12_5) + (sp6C * temp_f20_3) + sp7C, temp_f2_3 = (sp50 * temp_f4_7) + (sp60 * temp_f12_5) + (sp70 * temp_f20_3) + sp80, temp_f4_8 = (sp54 * temp_f4_7) + (sp64 * temp_f12_5) + (sp74 * temp_f20_3) + sp84, (temp_f4_8 != 0.0f)) && ((temp_f0_3 = 1.0f / temp_f4_8, temp_f4_9 = temp_f6_3 * temp_f0_3, temp_f12_6 = temp_f8_3 * temp_f0_3, !((temp_f2_3 * temp_f0_3) > -1.0f)) || !(temp_f4_9 >= -1.0f) || !(temp_f4_9 <= 1.0f) || !(temp_f12_6 >= -1.0f) || !(temp_f12_6 <= 1.0f))))) {
                    if ((sp98 != 0.0f) && (spA0 != 0.0f)) {
                        temp_f4_10 = centerX + sp98;
                        temp_f12_7 = centerY + spA0;
                        temp_f20_4 = centerZ - temp_f28;
                        temp_f6_4 = (sp48 * temp_f4_10) + (sp58 * temp_f12_7) + (sp68 * temp_f20_4) + sp78;
                        temp_f8_4 = (sp4C * temp_f4_10) + (sp5C * temp_f12_7) + (sp6C * temp_f20_4) + sp7C;
                        temp_f2_4 = (sp50 * temp_f4_10) + (sp60 * temp_f12_7) + (sp70 * temp_f20_4) + sp80;
                        temp_f4_11 = (sp54 * temp_f4_10) + (sp64 * temp_f12_7) + (sp74 * temp_f20_4) + sp84;

                        if (temp_f4_11 != 0.0f) {
                            temp_f0_4 = 1.0f / temp_f4_11;
                            temp_f4_12 = temp_f6_4 * temp_f0_4;
                            temp_f12_8 = temp_f8_4 * temp_f0_4;
                            if (((temp_f2_4 * temp_f0_4) > -1.0f) && (temp_f4_12 >= -1.0f) && (temp_f4_12 <= 1.0f) && (temp_f12_8 >= -1.0f)) {
                                if (!(temp_f12_8 <= 1.0f)) {
                                    goto block_36;
                                }
                            } else {
                                goto block_37;
                            }
                        }
                    } else {
block_36:
block_37:
                        if (((temp_f28 == 0.0f) || ((temp_f4_13 = centerX - sp98, temp_f12_9 = centerY - spA0, temp_f20_5 = centerZ + temp_f28, temp_f6_5 = (sp48 * temp_f4_13) + (sp58 * temp_f12_9) + (sp68 * temp_f20_5) + sp78, temp_f8_5 = (sp4C * temp_f4_13) + (sp5C * temp_f12_9) + (sp6C * temp_f20_5) + sp7C, temp_f2_5 = (sp50 * temp_f4_13) + (sp60 * temp_f12_9) + (sp70 * temp_f20_5) + sp80, temp_f4_14 = (sp54 * temp_f4_13) + (sp64 * temp_f12_9) + (sp74 * temp_f20_5) + sp84, (temp_f4_14 != 0.0f)) && ((temp_f0_5 = 1.0f / temp_f4_14, temp_f4_15 = temp_f6_5 * temp_f0_5, temp_f12_10 = temp_f8_5 * temp_f0_5, !((temp_f2_5 * temp_f0_5) > -1.0f)) || !(temp_f4_15 >= -1.0f) || !(temp_f4_15 <= 1.0f) || !(temp_f12_10 >= -1.0f) || !(temp_f12_10 <= 1.0f)))) && ((sp98 == 0.0f) || (temp_f28 == 0.0f) || ((temp_f4_16 = centerX + sp98, temp_f12_11 = centerY - spA0, temp_f20_6 = centerZ + temp_f28, temp_f6_6 = (sp48 * temp_f4_16) + (sp58 * temp_f12_11) + (sp68 * temp_f20_6) + sp78, temp_f8_6 = (sp4C * temp_f4_16) + (sp5C * temp_f12_11) + (sp6C * temp_f20_6) + sp7C, temp_f2_6 = (sp50 * temp_f4_16) + (sp60 * temp_f12_11) + (sp70 * temp_f20_6) + sp80, temp_f4_17 = (sp54 * temp_f4_16) + (sp64 * temp_f12_11) + (sp74 * temp_f20_6) + sp84, (temp_f4_17 != 0.0f)) && ((temp_f0_6 = 1.0f / temp_f4_17, temp_f4_18 = temp_f6_6 * temp_f0_6, temp_f12_12 = temp_f8_6 * temp_f0_6, !((temp_f2_6 * temp_f0_6) > -1.0f)) || !(temp_f4_18 >= -1.0f) || !(temp_f4_18 <= 1.0f) || !(temp_f12_12 >= -1.0f) || !(temp_f12_12 <= 1.0f)))) && ((spA0 == 0.0f) || (temp_f28 == 0.0f) || ((temp_f4_19 = centerX - sp98, temp_f12_13 = centerY + spA0, temp_f20_7 = centerZ + temp_f28, temp_f6_7 = (sp48 * temp_f4_19) + (sp58 * temp_f12_13) + (sp68 * temp_f20_7) + sp78, temp_f8_7 = (sp4C * temp_f4_19) + (sp5C * temp_f12_13) + (sp6C * temp_f20_7) + sp7C, temp_f2_7 = (sp50 * temp_f4_19) + (sp60 * temp_f12_13) + (sp70 * temp_f20_7) + sp80, temp_f4_20 = (sp54 * temp_f4_19) + (sp64 * temp_f12_13) + (sp74 * temp_f20_7) + sp84, (temp_f4_20 != 0.0f)) && ((temp_f0_7 = 1.0f / temp_f4_20, temp_f4_21 = temp_f6_7 * temp_f0_7, temp_f12_14 = temp_f8_7 * temp_f0_7, !((temp_f2_7 * temp_f0_7) > -1.0f)) || !(temp_f4_21 >= -1.0f) || !(temp_f4_21 <= 1.0f) || !(temp_f12_14 >= -1.0f) || !(temp_f12_14 <= 1.0f)))) && ((sp98 == 0.0f) || (spA0 == 0.0f) || (temp_f28 == 0.0f) || ((temp_f4_22 = centerX + sp98, temp_f12_15 = centerY + spA0, temp_f20_8 = centerZ + temp_f28, temp_f6_8 = (sp48 * temp_f4_22) + (sp58 * temp_f12_15) + (sp68 * temp_f20_8) + sp78, temp_f8_8 = (sp4C * temp_f4_22) + (sp5C * temp_f12_15) + (sp6C * temp_f20_8) + sp7C, temp_f2_8 = (sp50 * temp_f4_22) + (sp60 * temp_f12_15) + (sp70 * temp_f20_8) + sp80, temp_f4_23 = (sp54 * temp_f4_22) + (sp64 * temp_f12_15) + (sp74 * temp_f20_8) + sp84, (temp_f4_23 != 0.0f)) && ((temp_f0_8 = 1.0f / temp_f4_23, temp_f4_24 = temp_f6_8 * temp_f0_8, temp_f12_16 = temp_f8_8 * temp_f0_8, !((temp_f2_8 * temp_f0_8) > -1.0f)) || !(temp_f4_24 >= -1.0f) || !(temp_f4_24 <= 1.0f) || !(temp_f12_16 >= -1.0f) || !(temp_f12_16 <= 1.0f))))) {
                            cond = TRUE;
                        }
                    }
                }

                if (cond) {
                    continue;
                }
            }

            transform_point(camera->perspectiveMatrix[0], centerX, centerY, centerZ, 1.0f, &sp38, &sp3C, &sp40, &sp44);
            distance = sp40 + 5000.0f;
            if (distance < 0) {
                distance = 0;
            } else if (distance > 10000) {
                distance = 10000;
            }
            rtPtr->appendGfxArg = model;
            if (model->modelNode->type == SHAPE_TYPE_GROUP) {
                rtPtr->appendGfx = appendGfx_model_group;
            } else {
                rtPtr->appendGfx = appendGfx_model;
            }
            rtPtr->distance = -distance;
            rtPtr->renderMode = model->renderMode;
            queue_render_task(rtPtr);
        }
    }

    for (i = 0; i < ARRAY_COUNT(*gCurrentTransformGroups); i++) {
        ModelTransformGroup* group = (*gCurrentTransformGroups)[i];
        f32 centerX, centerY, centerZ;
        s32 distance;

        if (group == NULL) {
            continue;
        }
        if (group->flags == 0) {
            continue;
        }
        if (group->flags & MODEL_TRANSFORM_GROUP_FLAGS_4) {
            continue;
        }

        centerX = group->center.x;
        centerY = group->center.y;
        centerZ = group->center.z;

        transform_point(camera->perspectiveMatrix, centerX, centerY, centerZ, 1.0f, &sp38, &sp3C, &sp40, &sp44);
        if (sp44 == 0.0f) {
            sp44 = 1.0f;
        }

        distance = (sp40 / sp44) * 10000.0f;

        if (!(group->flags & MODEL_TRANSFORM_GROUP_FLAGS_2)) {
            rtPtr->appendGfx = render_transform_group;
            rtPtr->appendGfxArg = group;
            rtPtr->distance = -distance;
            rtPtr->renderMode = group->renderMode;
            queue_render_task(rtPtr);
        }
    }
}
#else
INCLUDE_ASM(s32, "a5dd0_len_114e0", render_models);
#endif

void appendGfx_model_group(Model* model) {
    s32 modelTreeDepth = (*mdl_currentModelTreeNodeInfo)[model->modelID].treeDepth;
    s32 i;

    for (i = model->modelID - 1; i >= 0; i--) {
        if (modelTreeDepth >= (*mdl_currentModelTreeNodeInfo)[i].treeDepth) {
            break;
        }
    }

    mdl_treeIterPos = i + 1;
    func_80117D00(model);
}

void func_80117D00(Model* model) {
    Model* mdl = model; // temps needed to match
    ModelNode* modelNode = mdl->modelNode;

    if (model->modelNode->type != SHAPE_TYPE_MODEL) {
        if (modelNode->groupData != NULL) {
            s32 numChildren = modelNode->groupData->numChildren;

            if (numChildren != 0) {
                s32 i;

                for (i = 0; i < numChildren; i++, mdl_treeIterPos++) {
                    Model newModel = *mdl;
                    ModelNodeProperty* prop;

                    newModel.flags = mdl->flags;
                    newModel.currentSpecialMatrix = mdl->currentSpecialMatrix;
                    newModel.modelNode = modelNode->groupData->childList[i];
                    newModel.texPannerID = mdl->texPannerID;
                    newModel.customGfxIndex = mdl->customGfxIndex;

                    if (newModel.modelNode->type == SHAPE_TYPE_MODEL) {
                        prop = get_model_property(newModel.modelNode, MODEL_PROP_KEY_RENDER_MODE);
                    } else {
                        prop = NULL;
                    }

                    if (prop != NULL) {
                        newModel.renderMode = prop->data.s;
                    } else {
                        newModel.renderMode = 0;
                    }

                    newModel.textureID = (*mdl_currentModelTreeNodeInfo)[mdl_treeIterPos].textureID;
                    newModel.textureVariation = 0;
                    func_80117D00(&newModel);
                }
            }
        }
    } else {
        appendGfx_model(mdl);
    }
}

// this looks like a switch, but I can't figure it out
void render_transform_group_node(ModelNode* node) {
    Gfx** gfx = &gMasterGfxPos;
    Model* model;

    if (node != NULL) {
        if (node->type == SHAPE_TYPE_GROUP) {
            ModelNodeProperty* groupTypeProp = get_model_property(node, MODEL_PROP_KEY_GROUP_TYPE);

            if (groupTypeProp != NULL && groupTypeProp->data.s != 0) {
                model = get_model_from_list_index(mdl_currentTransformGroupChildIndex);
                if (!(model->flags & MODEL_FLAGS_ENABLED)) {
                    appendGfx_model_group(model);
                }
                mdl_currentTransformGroupChildIndex++;
                return;
            }
        }
        if (node->type != SHAPE_TYPE_MODEL) {
            if (node->groupData != NULL) {
                s32 numChildren;
                s32 i;

                if (node->groupData->transformMatrix != NULL) {
                    gSPMatrix((*gfx)++, node->groupData->transformMatrix,
                              G_MTX_PUSH | G_MTX_MUL | G_MTX_MODELVIEW);
                }

                numChildren = node->groupData->numChildren;
                if (numChildren != 0) {
                    for (i = 0; i < numChildren; i++) {
                        render_transform_group_node(node->groupData->childList[i]);
                    }
                }

                if (node->groupData->transformMatrix != NULL) {
                    gSPPopMatrix((*gfx)++, G_MTX_MODELVIEW);
                }
            }
            return;
        }

        model = get_model_from_list_index(mdl_currentTransformGroupChildIndex);
        if (!(model->flags & MODEL_FLAGS_ENABLED)) {
            appendGfx_model(model);
        }
        mdl_currentTransformGroupChildIndex++;
    }
}


// arg0 and gfx temps needed
void render_transform_group(ModelTransformGroup* group) {
    ModelTransformGroup* mtg = group;
    Gfx** gfx = &gMasterGfxPos;

    if (!(mtg->flags & MODEL_TRANSFORM_GROUP_FLAGS_4)) {
        mdl_currentTransformGroupChildIndex = mtg->minChildModelIndex;
        if (!(mtg->flags & MODEL_TRANSFORM_GROUP_FLAGS_2000)) {
            gSPMatrix((*gfx)++, mtg->transformMtx, (G_MTX_PUSH | G_MTX_LOAD) | G_MTX_MODELVIEW);
        }

        render_transform_group_node(mtg->modelNode);
        if (!(mtg->flags & MODEL_TRANSFORM_GROUP_FLAGS_2000)) {
            gSPPopMatrix((*gfx)++, G_MTX_MODELVIEW);
        }
        gDPPipeSync((*gfx)++);
    }
}

INCLUDE_ASM(s32, "a5dd0_len_114e0", func_801180E8);

Model* get_model_from_list_index(s32 listIndex) {
    return (*gCurrentModels)[listIndex];
}

void load_data_for_models(ModelNode* model, s32 romOffset, s32 size) {
    Matrix4f mtx;

    guMtxIdentF(mtx);

    if (romOffset != 0) {
        load_model_textures(model, romOffset, size);
    }

    *gCurrentModelTreeRoot = model;
    mdl_treeIterPos = 0;

    if (model != NULL) {
        load_model_transforms(model, NULL, mtx, 0);
    }
}

// tiny reg swap in the first loop
#ifdef NON_EQUIVALENT
void load_model_transforms(ModelNode* model, ModelNode* parent, Matrix4f mdlTxMtx, s32 treeDepth) {
    Matrix4f sp10;
    Matrix4f sp50;
    ModelBlueprint modelBP;
    ModelBlueprint* modelBPptr = &modelBP;
    ModelNodeProperty* groupTypeProperty;
    s32 i;

    if (model->groupData != NULL && model->groupData->numChildren != 0) {
        s32 groupType;

        if (model->groupData->transformMatrix != NULL) {
            Matrix4f spA0;

            guMtxL2F(spA0, model->groupData->transformMatrix);
            guMtxCatF(spA0, mdlTxMtx, sp10);
        }
        groupTypeProperty = get_model_property(model, MODEL_PROP_KEY_GROUP_TYPE);

        if (groupTypeProperty == NULL) {
            groupType = 0;
        } else {
            groupType = groupTypeProperty->data.s;
        }

        if (model->type != 5 || groupType == 0) {
            for (i = 0; i < model->groupData->numChildren; i++) {
                ModelNode** modelTemp;
                Matrix4f* txMtx;

                modelTemp = &model->groupData->childList[i];

                if (model->groupData->transformMatrix != NULL) {
                    txMtx = sp10;
                } else {
                    txMtx = mdlTxMtx;
                }

                load_model_transforms(*modelTemp, model, txMtx, treeDepth + 1);
            }

            (*mdl_currentModelTreeNodeInfo)[mdl_treeIterPos].modelIndex = -1;
            (*mdl_currentModelTreeNodeInfo)[mdl_treeIterPos].treeDepth = treeDepth;
            mdl_treeIterPos += 1;
            return;
        }
    }

    guMtxF2L(mdlTxMtx, sp50);
    modelBPptr->flags = 0;
    modelBPptr->mdlNode = model;
    modelBPptr->groupData = parent->groupData;
    modelBPptr->mtx = sp50;

    if (model->type == 5) {
        s32 childCount = mdl_get_child_count(model);

        for (i = mdl_treeIterPos; i < mdl_treeIterPos + childCount; i++) {
            (*mdl_currentModelTreeNodeInfo)[i].modelIndex = -1;
            (*mdl_currentModelTreeNodeInfo)[i].treeDepth = treeDepth + 1;
        }
        mdl_treeIterPos += childCount;
    }

    mdl_create_model(modelBPptr, 4);
    (*mdl_currentModelTreeNodeInfo)[mdl_treeIterPos].treeDepth = treeDepth;
    mdl_treeIterPos += 1;
}
#else
INCLUDE_ASM(s32, "a5dd0_len_114e0", load_model_transforms);
#endif

s32 get_model_list_index_from_tree_index(s32 treeIndex) {
    s32 i;

    if (treeIndex < 0x100) {
        u8 modelIndex = (*mdl_currentModelTreeNodeInfo)[treeIndex].modelIndex;

        if (modelIndex != (u8)-1) {
            return modelIndex;
        }
    }

    for (i = 0; i < 0x100; i++) {
        Model* model = get_model_from_list_index(i);

        if (model != NULL && model->modelID == treeIndex) {
            return i;
        }
    }
    return 0;
}

s32 get_transform_group_index(s32 modelID) {
    ModelTransformGroup* group;
    s32 i;

    for (i = 0; i < MAX_MODEL_TRANSFORM_GROUPS; i++) {
        group = get_transform_group(i);

        if (group != NULL && group->groupModelID == modelID) {
            return i;
        }
    }

    return -1;
}

// TODO this seems to be returning center for the model and center for the BB (not the size)
void get_model_center_and_size(u16 modelID, f32* centerX, f32* centerY, f32* centerZ, f32* sizeX, f32* sizeY, f32* sizeZ) {
    Model* model = get_model_from_list_index(get_model_list_index_from_tree_index(modelID));
    ModelNode* node = model->modelNode;
    ModelBoundingBox* bb;

    *centerX = model->center.x;
    *centerY = model->center.y;
    *centerZ = model->center.z;

    bb = (ModelBoundingBox*)get_model_property(node, MODEL_PROP_KEY_BOUNDING_BOX);

    if (bb != NULL) {
        *sizeX = bb->halfSizeX;
        *sizeY = bb->halfSizeY;
        *sizeZ = bb->halfSizeZ;
    } else {
        *sizeX = *sizeY = *sizeZ = 0.0f;
    }
}

ModelTransformGroup* get_transform_group(s32 index) {
    return (*gCurrentTransformGroups)[index];
}

void func_8011B1D8(ModelNode* node) {
    ModelNode* childNode;
    ModelNodeProperty* prop;
    s32 numChildren;
    s32 i;
    u16 childCount;

    if (node->type == 2) {
        D_80153376 = D_80153226;
        return;
    }

    if (node->type == 5) {
        prop = get_model_property(node, MODEL_PROP_KEY_GROUP_TYPE);
        if (prop != NULL && prop->data.s != 0) {
            mdl_treeIterPos += mdl_get_child_count(node);
            D_80153376 = mdl_treeIterPos;
            return;
        }
    }

    if (node->groupData != NULL) {
        numChildren = node->groupData->numChildren;
        if (numChildren != 0) {
            for (i = 0; i < numChildren; i++) {
                childNode = node->groupData->childList[i];
                childCount = mdl_treeIterPos;
                if (childNode->type == 5) {
                    prop = get_model_property(childNode, MODEL_PROP_KEY_GROUP_TYPE);
                    if (prop != NULL && prop->data.s != 0) {
                        childCount += mdl_get_child_count(childNode);
                    }
                }
                func_8011B1D8(childNode);

                if (D_80153370 != NULL) {
                    break;
                }

                if (D_8015336E == mdl_treeIterPos) {
                    D_80153370 = childNode;
                    D_80153374 = childCount;
                    break;
                }

                mdl_treeIterPos++;
            }
        }
    }
}

void make_transform_group(u16 modelID) {
    mdl_treeIterPos = 0;
    D_80153370 = NULL;
    D_8015336E = modelID;
    D_80153376 = 0;
    D_80153374 = 0;
    func_8011B1D8(*gCurrentModelTreeRoot);

    if (D_80153370 != 0) {
        ModelTransformGroup* newMtg;
        ModelNode* node;
        ModelNodeProperty* prop;
        ModelBoundingBox* bb;
        f32 x, y, z;
        s32 i;

        for (i = 0; i < ARRAY_COUNT(*gCurrentTransformGroups); i++) {
            if ((*gCurrentTransformGroups)[i] == NULL) {
                break;
            }
        }

        (*gCurrentTransformGroups)[i] = newMtg = heap_malloc(sizeof(*newMtg));
        newMtg->flags = MODEL_TRANSFORM_GROUP_FLAGS_1;
        newMtg->groupModelID = modelID;
        newMtg->minChildModelIndex = get_model_list_index_from_tree_index(D_80153374);
        newMtg->maxChildModelIndex = get_model_list_index_from_tree_index(D_80153376);
        newMtg->matrixMode = 0;
        newMtg->matrixRDP_N = NULL;
        newMtg->modelNode = D_80153370;
        guMtxIdent(&newMtg->matrixA);
        newMtg->flags |= 0x2000;
        guMtxIdentF(newMtg->matrixB);

        node = newMtg->modelNode;

        if (node->type != SHAPE_TYPE_GROUP) {
            prop = get_model_property(node, MODEL_PROP_KEY_RENDER_MODE);
        } else {
            prop = get_model_property(node, MODEL_PROP_KEY_GROUP_TYPE);

            if (prop != NULL) {
                prop = &prop[1];
            }
        }

        if (prop != NULL) {
            newMtg->renderMode = prop->data.s;
        } else {
            newMtg->renderMode = 1;
        }

        bb = (ModelBoundingBox*)get_model_property(node, MODEL_PROP_KEY_BOUNDING_BOX);
        if (bb != NULL) {
            x = (bb->minX + bb->maxX) * 0.5f;
            y = (bb->minY + bb->maxY) * 0.5f;
            z = (bb->minZ + bb->maxZ) * 0.5f;
        } else {
            x = y = z = 0.0f;
        }

        if (newMtg->matrixRDP_N != NULL) {
            guMtxXFML(newMtg->matrixRDP_N, x, y, z, &x, &y, &z);
        }

        newMtg->center.x = x;
        newMtg->center.y = y;
        newMtg->center.z = z;
        enable_transform_group(modelID);
    }
}

void enable_transform_group(u16 modelID) {
    ModelTransformGroup* group = get_transform_group(get_transform_group_index(modelID));
    s32 i;

    group->flags &= ~0x4;

    for (i = group->minChildModelIndex; i <= group->maxChildModelIndex; i++) {
        Model* model = get_model_from_list_index(i);

        model->flags |= MODEL_FLAGS_TRANSFORM_GROUP_MEMBER;

        if (model->currentMatrix != NULL) {
            model->flags |= MODEL_FLAGS_USES_TRANSFORM_MATRIX;
        }
    }
}

void disable_transform_group(u16 modelID) {
    ModelTransformGroup* group = get_transform_group(get_transform_group_index(modelID));
    s32 i;

    group->flags |= MODEL_TRANSFORM_GROUP_FLAGS_4;

    for (i = group->minChildModelIndex; i <= group->maxChildModelIndex; i++) {
        Model* model = get_model_from_list_index(i);

        model->flags &= ~MODEL_FLAGS_TRANSFORM_GROUP_MEMBER;

        if (model->currentMatrix != NULL) {
            model->flags |= MODEL_FLAGS_USES_TRANSFORM_MATRIX;
        }
    }
}

void clone_model(u16 srcModelID, u16 newModelID) {
    Model* srcModel = get_model_from_list_index(get_model_list_index_from_tree_index(srcModelID));
    Model* newModel;
    s32 i;

    for (i = 0; i < ARRAY_COUNT(*gCurrentModels); i++) {
        if ((*gCurrentModels)[i] == NULL) {
            break;
        }
    }

    (*gCurrentModels)[i] = newModel = heap_malloc(sizeof(*newModel));
    *newModel = *srcModel;
    newModel->modelID = newModelID;
}

INCLUDE_ASM(void, "a5dd0_len_114e0", func_8011B7C0, u16 arg0, s32 arg1, s32 arg2);

INCLUDE_ASM(s32, "a5dd0_len_114e0", func_8011B950);

void func_8011BAE8(void) {
    s32 i;

    for (i = 0; i < ARRAY_COUNT(*gCurrentModels); i++) {
        Model* model = (*gCurrentModels)[i];

        if (model != NULL) {
            model->flags &= ~MODEL_FLAGS_HAS_TRANSFORM_APPLIED;
        }
    }

    for (i = 0; i < ARRAY_COUNT(*gCurrentTransformGroups); i++) {
        ModelTransformGroup* transformGroup = (*gCurrentTransformGroups)[i];

        if (transformGroup != NULL) {
            transformGroup->flags &= ~MODEL_TRANSFORM_GROUP_FLAGS_400;
        }
    }
}

void enable_world_fog(void) {
    gCurrentFogSettings->enabled = TRUE;
}

void disable_world_fog(void) {
    gCurrentFogSettings->enabled = FALSE;
}

void set_world_fog_dist(s32 start, s32 end) {
    gCurrentFogSettings->startDistance = start;
    gCurrentFogSettings->endDistance = end;
}

void set_world_fog_color(s32 r, s32 g, s32 b, s32 a) {
    gCurrentFogSettings->r = r;
    gCurrentFogSettings->g = g;
    gCurrentFogSettings->b = b;
    gCurrentFogSettings->a = a;
}

s32 is_world_fog_enabled(void) {
    return gCurrentFogSettings->enabled;
}

void get_world_fog_distance(s32* start, s32* end) {
    *start = gCurrentFogSettings->startDistance;
    *end = gCurrentFogSettings->endDistance;
}

void get_world_fog_color(s32* r, s32* g, s32* b, s32* a) {
    *r = gCurrentFogSettings->r;
    *g = gCurrentFogSettings->g;
    *b = gCurrentFogSettings->b;
    *a = gCurrentFogSettings->a;
}

void set_tex_panner(Model* model, s8 texPannerID) {
    model->texPannerID = texPannerID;
}

void set_main_pan_u(s32 texPannerID, s32 value) {
    texPannerMainU[texPannerID] = value;
}

void set_main_pan_v(s32 texPannerID, s32 value) {
    texPannerMainV[texPannerID] = value;
}

void set_aux_pan_u(s32 texPannerID, s32 value) {
    texPannerAuxU[texPannerID] = value;
}

void set_aux_pan_v(s32 texPannerID, s32 value) {
    texPannerAuxV[texPannerID] = value;
}

void set_mdl_custom_gfx_set(Model* model, s32 customGfxIndex, u32 fogType) {
    if (customGfxIndex == -1) {
        customGfxIndex = model->customGfxIndex & 15;
    }

    if (fogType == -1) {
        fogType = model->customGfxIndex / 16;
    }

    model->customGfxIndex = (customGfxIndex & 15) + ((fogType & 15) * 16);
}

void set_custom_gfx(s32 customGfxIndex, Gfx* pre, Gfx* post) {
    (*gCurrentCustomModelGfxPtr)[customGfxIndex * 2] = pre;
    (*gCurrentCustomModelGfxPtr)[customGfxIndex * 2 + 1] = post;
}

void set_custom_gfx_builders(s32 customGfxIndex, ModelCustomGfxBuilderFunc pre, ModelCustomGfxBuilderFunc post) {
    (*gCurrentCustomModelGfxBuildersPtr)[customGfxIndex * 2] = pre;
    (*gCurrentCustomModelGfxBuildersPtr)[customGfxIndex * 2 + 1] = post;
}

void build_custom_gfx(void) {
    Gfx* gfx = gMasterGfxPos;
    ModelCustomGfxBuilderFunc preFunc;
    ModelCustomGfxBuilderFunc postFunc;
    s32 i;

    gSPBranchList(gMasterGfxPos++, 0x00000000);

    for (i = 0; i < ARRAY_COUNT(*gCurrentCustomModelGfxPtr) / 2; i++) {
        preFunc = (*gCurrentCustomModelGfxBuildersPtr)[i * 2];

        if (preFunc != NULL) {
            (*gCurrentCustomModelGfxPtr)[i * 2] = gMasterGfxPos;
            preFunc(i);
            gSPEndDisplayList(gMasterGfxPos++);
        }

        postFunc = (*gCurrentCustomModelGfxBuildersPtr)[i * 2 + 1];
        if (postFunc != NULL) {
            (*gCurrentCustomModelGfxPtr)[i * 2 + 1] = gMasterGfxPos;
            postFunc(i);
            gSPEndDisplayList(gMasterGfxPos++);
        }
    }

    gSPBranchList(gfx, gMasterGfxPos);
}

// weird temps necessary to match
/// @returns TRUE if mtx is NULL or identity.
s32 is_identity_fixed_mtx(Matrix4s* mtx) {
    s32* mtxIt = (s32*)mtx;
    s32* identityIt;
    s32 i;

    if (mtx == NULL) {
        return TRUE;
    }

    identityIt = (s32*)&mdl_RDPIdentity;

    for (i = 0; i < 16; i++, mtxIt++, identityIt++) {
        if (*mtxIt != *identityIt) {
            return FALSE;
        }
    }

    return TRUE;
}

void set_background_color_blend(u8 r, u8 g, u8 b, u8 a) {
    mdl_bgMultiplyColorR = r;
    mdl_bgMultiplyColorG = g;
    mdl_bgMultiplyColorB = b;
    mdl_bgMultiplyColorA = a;
}

void get_background_color_blend(u8* r, u8* g, u8* b, u8* a) {
    *r = mdl_bgMultiplyColorR;
    *g = mdl_bgMultiplyColorG;
    *b = mdl_bgMultiplyColorB;
    *a = mdl_bgMultiplyColorA;
}

void set_model_fog_color_parameters(s8 primR, s8 primG, s8 primB, s8 primA, s32 fogR, s32 fogG, s32 fogB, s32 fogStart,
                                    s32 fogEnd) {
    mdl_renderModelFogPrimColorR = primR;
    mdl_renderModelFogPrimColorG = primG;
    mdl_renderModelFogPrimColorB = primB;
    mdl_renderModelFogPrimColorA = primA;
    mdl_renderModelFogColorR = fogR;
    mdl_renderModelFogColorG = fogG;
    mdl_renderModelFogColorB = fogB;
    mdl_renderModelFogStart = fogStart;
    mdl_renderModelFogEnd = fogEnd;
}

void get_model_fog_color_parameters(u8* primR, u8* primG, u8* primB, u8* primA, u8* fogR, u8* fogG, u8* fogB,
                                    s32* fogStart, s32* fogEnd) {
    *primR = mdl_renderModelFogPrimColorR;
    *primG = mdl_renderModelFogPrimColorG;
    *primB = mdl_renderModelFogPrimColorB;
    *primA = mdl_renderModelFogPrimColorA;
    *fogR = mdl_renderModelFogColorR;
    *fogG = mdl_renderModelFogColorG;
    *fogB = mdl_renderModelFogColorB;
    *fogStart = mdl_renderModelFogStart;
    *fogEnd = mdl_renderModelFogEnd;
}

void set_model_env_color_parameters(u8 primR, u8 primG, u8 primB, u8 envR, s32 envG, s32 envB) {
    gRenderModelPrimR = primR;
    gRenderModelPrimG = primG;
    gRenderModelPrimB = primB;
    gRenderModelEnvR = envR;
    gRenderModelEnvG = envG;
    gRenderModelEnvB = envB;
}

void get_model_env_color_parameters(u8* primR, u8* primG, u8* primB, u8* envR, u8* envG, u8* envB) {
    *primR = gRenderModelPrimR;
    *primG = gRenderModelPrimG;
    *primB = gRenderModelPrimB;
    *envR = gRenderModelEnvR;
    *envG = gRenderModelEnvG;
    *envB = gRenderModelEnvB;
}

void mdl_get_vertex_count(Gfx* gfx, s32* numVertices, s32* baseVtx, s32* gfxCount, Vtx* baseAddr) {
    s8 stuff[2];

    s32 vtxCount;
    u32 w0, w1;
    u32 cmd;
    u32 vtxEndAddr;
    s32 minVtx;
    s32 maxVtx;
    u32 vtxStartAddr;

    minVtx = 0;
    maxVtx = 0;

    if (gfx == NULL) {
        *numVertices = maxVtx;
        *baseVtx = minVtx;
    } else {
        Gfx* baseGfx = gfx;

        do {
            w0 = gfx->words.w0;
            w1 = gfx->words.w1;
            cmd = _SHIFTR(w0,24,8);

            if (cmd == G_VTX) {
                vtxStartAddr = w1;
                if (baseAddr != NULL) {
                    vtxStartAddr = (vtxStartAddr & 0xFFFF) + (s32)baseAddr;
                }
                vtxCount = _SHIFTR(w0,12,8);
                if (minVtx == 0) {
                    minVtx = vtxStartAddr;
                    maxVtx = vtxStartAddr + (vtxCount * sizeof(Vtx));
                }
                vtxEndAddr = vtxStartAddr + (vtxCount * sizeof(Vtx));
                if (maxVtx < vtxEndAddr) {
                    maxVtx = vtxEndAddr;
                }
                if (minVtx > vtxEndAddr) {
                    minVtx = vtxEndAddr;
                }
            }
            gfx++;
        } while (cmd != G_ENDDL);

        *numVertices = (maxVtx - minVtx) >> 4;
        *baseVtx = minVtx;
        *gfxCount = gfx - baseGfx;
        w1 = gfx->words.w1; // TODO required to match
    }
}

INCLUDE_ASM(s32, "a5dd0_len_114e0", mdl_local_gfx_update_vtx_pointers);

void mdl_local_gfx_copy_vertices(u8* from, s32 num, u8* to) {
    u32 i;

    for (i = 0; i < num * 16; i++) {
        to[i] = from[i];
    }
}

INCLUDE_ASM(s32, "a5dd0_len_114e0", mdl_make_local_vertex_copy);

void mdl_get_copied_vertices(s32 copyIndex, Vtx** firstVertex, Vtx** copiedVertices, s32* numCopied) {
    ModelLocalVertexCopy* mlvc = (*gCurrentModelLocalVtxBuffers)[copyIndex];
    s32 selector = mlvc->selector;

    *firstVertex = mlvc->minVertexAddr;
    *copiedVertices = mlvc->vtxCopy[selector];
    *numCopied = mlvc->numVertices;
}

Gfx* mdl_get_copied_gfx(s32 copyIndex) {
    ModelLocalVertexCopy* mlvc = (*gCurrentModelLocalVtxBuffers)[copyIndex];
    s32 selector = mlvc->selector;
    Gfx* gfxCopy = mlvc->gfxCopy[selector];

    mlvc->selector++;
    if (mlvc->selector >= 2) {
        mlvc->selector = 0;
    }

    return gfxCopy;
}

void mdl_project_tex_coords(s32 modelID, Gfx* destGfx, Matrix4f* destMtx, Vtx* destVertices);
INCLUDE_ASM(s32, "a5dd0_len_114e0", mdl_project_tex_coords);

INCLUDE_ASM(s32, "a5dd0_len_114e0", func_8011C80C);

INCLUDE_ASM(s32, "a5dd0_len_114e0", func_8011CFBC);

void mdl_draw_hidden_panel_surface(Gfx** arg0, u16 treeIndex) {
    Model* model = get_model_from_list_index(get_model_list_index_from_tree_index(treeIndex));
    Model copied = *model;
    Gfx* oldGfxPos;
    s32 flag;

    if (*arg0 == gMasterGfxPos) {
        flag = 1;
    }

    oldGfxPos = gMasterGfxPos;
    gMasterGfxPos = *arg0;

    copied.flags = 0x80 | 0x1;
    appendGfx_model(&copied);

    *arg0 = gMasterGfxPos;

    if (flag == 0) {
        gMasterGfxPos = oldGfxPos;
    }
}

s32 mdl_get_next_texture_address(s32 size) {
    u32 offset = mdl_nextTextureAddress - mdl_textureBaseAddress + 0x3F;

    offset = (offset >> 6) << 6;

    if (size + offset > 0x28000) {
        return 0;
    } else {
        return mdl_textureBaseAddress + offset;
    }

}

void mdl_set_all_fog_mode(s32 fogMode) {
    ModelList* modelList = gCurrentModels;
    Model* model;
    s32 fogType = fogMode; // weirdness here and the next line needed to match
    s32 i = fogMode;

    for (i = 0; i < ARRAY_COUNT(*modelList); i++) {
        model = (*modelList)[i];

        if (model != NULL) {
            set_mdl_custom_gfx_set(model, -1, fogType);
        }
    }
}

void clear_render_tasks(void) {
    s32 i;

    for (i = 0; i < ARRAY_COUNT(mdl_clearRenderTasks); i++) {
        mdl_renderTaskLists[i] = mdl_clearRenderTasks[i];
    }

    mdl_renderTaskQueueIdx = 0;
    mdl_renderTaskCount = 0;
}

void clear_render_tasks_alt(void) {
    s32 i;

    for (i = 0; i < ARRAY_COUNT(mdl_clearRenderTasks); i++) {
        mdl_renderTaskLists[i] = mdl_clearRenderTasks[i];
    }

    mdl_renderTaskQueueIdx = 0;
    mdl_renderTaskCount = 0;
}

RenderTask* queue_render_task(RenderTask* task) {
    RenderTask* ret = mdl_renderTaskLists[mdl_renderTaskQueueIdx];

    ASSERT(mdl_renderTaskCount < ARRAY_COUNT(*mdl_clearRenderTasks));

    ret = &ret[mdl_renderTaskCount++];

    ret->renderMode = RENDER_TASK_FLAG_ENABLED;
    if (task->renderMode == RENDER_MODE_2D) {
        ret->renderMode |= RENDER_TASK_FLAG_20;
    }

    ret->appendGfxArg = task->appendGfxArg;
    ret->appendGfx = task->appendGfx;
    ret->distance = mdl_renderTaskBasePriorities[task->renderMode] - task->distance;

    return ret;
}

void execute_render_tasks(void) {
    s32 i, j, taskCount;
    s32 sorted[ARRAY_COUNT(*mdl_clearRenderTasks)];
    RenderTask* taskList;
    RenderTask* task;
    RenderTask* task2;
    Matrix4f mtxFlipY;
    void (*appendGfx)(void*);

    if (mdl_renderTaskCount == 0) {
        return;
    }

    for (i = taskCount = 0; i < mdl_renderTaskCount; i++) {
        sorted[taskCount++] = i;
    }

    // sort in ascending order
    taskList = mdl_renderTaskLists[mdl_renderTaskQueueIdx];
    for (i = 0; i < taskCount - 1; i++) {
        for (j = i + 1; j < taskCount; j++) {
            s32 t1 = sorted[i];
            s32 t2 = sorted[j];
            task = &taskList[t1];
            task2 = &taskList[t2];
            if (task->distance > task2->distance) {
                sorted[i] = t2;
                sorted[j] = t1;
            }
        }
    }

    // tasks with dist >= 3M sort in descending order
    taskList = mdl_renderTaskLists[mdl_renderTaskQueueIdx];
    for (i = 0; i < taskCount - 1; i++) {
        task = &taskList[sorted[i]];
        if (task->distance >= 3000000) {
            for (j = i + 1; j < taskCount; j++) {
                s32 t1 = sorted[i];
                s32 t2 = sorted[j];
                task = &taskList[t1];
                task2 = &taskList[t2];
                if (task->distance < task2->distance) {
                    sorted[i] = t2;
                    sorted[j] = t1;
                }
            }
        }
    }

    // tasks with dist <= 800k sort in descending order
    taskList = mdl_renderTaskLists[mdl_renderTaskQueueIdx];
    for (i = 0; i < taskCount - 1; i++) {
        task = &taskList[sorted[i]];
        if (task->distance > 800000) {
            break;
        }
        for (j = i + 1; j < taskCount; j++) {
            s32 t1 = sorted[i];
            s32 t2 = sorted[j];
            task = &taskList[t1];
            task2 = &taskList[t2];
            if (task2->distance > 800000) {
                break;
            }
            if (task->distance < task2->distance) {
                sorted[i] = t2;
                sorted[j] = t1;
            }
        }
    }

    D_8014B7F0 = taskCount;
    taskList = mdl_renderTaskLists[mdl_renderTaskQueueIdx];
    if (gOverrideFlags & GLOBAL_OVERRIDES_80) {
        Mtx* dispMtx;
        Gfx* savedGfxPos = NULL;

        guScaleF(mtxFlipY, 1.0f, -1.0f, 1.0f);
        guMtxF2L(mtxFlipY, &gDisplayContext->matrixStack[gMatrixListPos]);
        dispMtx = &gDisplayContext->matrixStack[gMatrixListPos++];
        for (i = 0; i < taskCount; i++) {
            task = &taskList[sorted[i]];
            appendGfx = task->appendGfx;

            if (task->renderMode & RENDER_TASK_FLAG_2) {
                savedGfxPos = gMasterGfxPos++;
            }

            appendGfx(task->appendGfxArg);

            if (task->renderMode & RENDER_TASK_FLAG_2) {
                gSPEndDisplayList(gMasterGfxPos++);
                gSPBranchList(savedGfxPos, gMasterGfxPos);
                gSPDisplayList(gMasterGfxPos++, savedGfxPos + 1);
                gSPMatrix(gMasterGfxPos++, dispMtx, G_MTX_NOPUSH | G_MTX_MUL | G_MTX_PROJECTION);
                gSPDisplayList(gMasterGfxPos++, savedGfxPos + 1);
                gSPMatrix(gMasterGfxPos++, &gDisplayContext->camPerspMatrix[gCurrentCamID], G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_PROJECTION);
            }
        }
    } else {
        for (i = 0; i < taskCount; i++) {
            task = &taskList[sorted[i]];
            appendGfx = task->appendGfx;
            appendGfx(task->appendGfxArg);
        }
    }

    mdl_renderTaskQueueIdx++;
    if (mdl_renderTaskQueueIdx > 2) {
        mdl_renderTaskQueueIdx = 0;
    }
    mdl_renderTaskCount = 0;
}
